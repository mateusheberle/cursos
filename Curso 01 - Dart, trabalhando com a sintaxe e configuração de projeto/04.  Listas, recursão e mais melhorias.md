# Listas, recursão e mais melhorias

## Lista de operações

### Projeto calculadora

**/bin/calculadora.dart**
```dart
import 'dart:io';

void main(){
    /* Declarações de variáveis */
    double numeroUm = 0;
    double numeroDois = 0;
    String operacao = "";
    String? entrada = "";
    List<String> operacoes = <String>["+", "-", "*", "/"];

    /* Declarações de funções */
    void soma(){
        print(numeroUm + numeroDois);
    }
    void subtracao(){
        print(numeroUm - numeroDois);
    }
    void divisao(){
        print(numeroUm / numeroDois);
    }
    void multiplicacao(){
        print(numeroUm * numeroDois);
    }
    void calcular(){
        switch (operacao) {
            case "+":
            soma();
            
            case "-":
            subtracao();
            
            case "*":
            multiplicacao();
            
            case "/":
            divisao();

            break;
        }
    }
    void getOperacao() {
        print("Digite uma operação ${operacoes.toString()}")
        entrada = stdin.readLineSync();
        if (entrada != null) {
            if (operacoes.contains(entrada)) {
                operacao = entrada!;
            } else {
                print("Operação inválida");
                getOperacao();
            }
        }
    }

    /* Começa efetivamente a "Calculadora" */
    print("Digite o primeiro valor");

    entrada = stdin.readLineSync();

    if (entrada != null) {
        if (entrada != "") {
            numeroUm = double.parse(entrada!);
        }
    }

    getOperacao();

    print("Digite o segundo valor");

    entrada = stdin.readLineSync();
    if (entrada != null) {
        if (entrada != "") {
            numeroDois = double.parse(entrada!);
        }
    }

    print("O resultado da operação é:")

    calcular();

}
```
    "Nosso trabalhado como desenvolvedores é escrever o código mais seguros e robusto possível."


- **Listas**: São formas de guardar informações.
- `List<String> operacoes = <String>[];`: Declaração de uma lista.

- **Recursão**: Quando chama uma função dentro dela mesma. 

- *Interpolação "compostas"*: `${operacoes.toString()}`
- *Interpolação "simples"*: `$entrada`

## Para saber mais: o superpoder das listas no Dart

[Artigo: Conhecendo as funções da lista em Dart](https://codeburst.io/top-10-array-utility-methods-you-should-know-dart-feb2648ee3a2)

Os **10 principais métodos** utilitários de array que você deve conhecer (Dart).

* 01. `forEach()`:

Executa uma função em cada elemento da lista.

```dart
var fruits = ['banana', 'pineapple', 'watermelon'];
fruits.forEach((fruit) => print(fruit));    // => banana pineapple watermelon
```

* 02. `map()`:

Produz uma nova lista após transformar cada elemento em uma lista fornecida.

```dart
var mappedFruits = fruits.map((fruit) => 'I love $fruit').toList();
print(mappedFruits);    // => ['I love banana', ‘I love pineapple’, ‘I love watermelon’]
```

* 03. `contains()`:

Verifica para confirmar se o elemento fornecido está na lista.

```dart
var numbers = [1, 3, 2, 5, 4];
print(numbers.contains(2));     // => true
```

* 04. `sort()`:

Ordene os elementos com base na função de ordenação fornecida.

```dart
numbers.sort((num1, num2) => num1 - num2); // => [1, 2, 3, 4, 5]
```

* 05. `reduce(), fold()`:

Compacta os elementos em um único valor, usando a função fornecida.

```dart
var sum = numbers.reduce((curr, next) => curr + next);
print(sum);     // => 15

const initialValue = 10;
var sum2 = numbers.fold(initialValue, (curr, next) => curr + next);
print(sum2);    // => 25
```

* 06. `every()`:

Confirma que cada elemento satisfaz o teste.

```dart
List<Map<String, dynamic>> users = [
  { "name": 'John', "age": 18 },
  { "name": 'Jane', "age": 21 },
  { "name": 'Mary', "age": 23 },
];
var is18AndOver = users.every((user) => user["age"] >= 18);
print(is18AndOver);     // => true
  
var hasNamesWithJ = users.every((user) => user["name"].startsWith('J'));
print(hasNamesWithJ);   // => false
```

* 07. `where(), firstWhere(), singleWhere()`:

Retorna uma coleção de elementos que satisfazem um teste.

```dart
// See #6 for users list
var over21s = users.where((user) => user["age"] > 21);
print(over21s.length);  // => 1

var nameJ = users.firstWhere((user) => user["name"].startsWith(‘J’), orElse: () => null);
print(nameJ);           // => {name: John, age: 18}

var under18s = users.singleWhere((user) => user["age"] < 18, orElse: () => null);
print(under18s);        // => null
```

* 08. `take(), skip()`:

Retorna uma coleção ao incluir ou pular elementos.

```dart
var fiboNumbers = [1, 2, 3, 5, 8, 13, 21];
print(fiboNumbers.take(3).toList());                    // => [1, 2, 3]
print(fiboNumbers.skip(5).toList());                    // => [13, 21]
print(fiboNumbers.take(3).skip(2).take(1).toList());    // => [3]
```

* 09. `List.from()`:

Cria uma nova lista a partir da coleção fornecida.

```dart
var clonedFiboNumbers = List.from(fiboNumbers);
print('Cloned list: $clonedFiboNumbers');
```

* 10. `expand()`:

Expande cada elemento em zero ou mais elementos.

```dart
var pairs = [[1, 2], [3, 4]];
var flattened = pairs.expand((pair) => pair).toList();
print(‘Flattened result: $flattened’);      // => [1, 2, 3, 4]

var input = [1, 2, 3];
var duplicated = input.expand((i) => [i, i]).toList();
print(duplicated);                          // => [1, 1, 2, 2, 3, 3]
```


## Para saber mais: recursividade

No Dart, essa funcionalidade permite que *funções chamem a si mesmas*.


### Exemplo de cálculo fatorial

```dart
int fatorial(int n) {
    if (n == 0) {
        return 1;                       // Caso base: fatorial de 0 é definido como 1
    } else {
        return n * fatorial(n - 1);     // Chamada recursiva: multiplica n por fatorial(n - 1)
    }
}

void main() {
    int resultado = fatorial(5);    // Armazena o resultado do fatorial de 5
    print(resultado);               // Exibe o valor do fatorial: 120 (5 * 4 * 3 * 2 * 1)
}
```

*Vantagens da recursividade*:

* Algoritmos mais concisos e legíveis.
* Desempenho otimizado em alguns casos.

## Lista de exercícios

01. Validação de categorias de produtos em um sistema de estoque.
```dart
import 'dart:io';

void main() {
    List<String> categorias = ['eletronicos', 'alimentos', 'vestuario', 'livros'];
    String? categoria;

    categoria = validaCategoria(categoria, categorias);

    print('Categoria válida: $categoria');
}

String? validaCategoria(String? categoria, List<String> categorias) {
    print('Digite a categoria do produto (eletronicos, alimentos, vestuario, livros):');
    categoria = stdin.readLineSync();
    if (categorias.contains(categoria)) {
        return categoria;
    } else {
        print('Categoria inválida. Tente novamente.');
        return validaCategoria(categoria, categorias);
    }
}
```

02. Validação de tipos de arquivos em um sistema de upload.
```dart
import 'dart:io';

void main() {
    List<String> tipos = ['pdf', 'jpg', 'png', 'docx'];
    String? tipo;

    tipo = validaTipo(tipo, tipos);

    print('Tipo válido: $tipo');
}

String? validaTipo(String? tipo, List<String> tipos) {
    print('Digite o tipo do arquivo (pdf, jpg, png, docx):');
    tipo = stdin.readLineSync();
    if (tipos.contains(tipo)) {
        return tipo;
    } else {
        print('Tipo inválido. Tente novamente.');
        return validaTipo(tipo, tipos);
    }
}
```

03. Dando uma nova chance no retorno de mês.
```dart
import 'dart:io';

void main() {
  solicitarNumero();
}

void solicitarNumero() {
    print('Digite um número de 1 a 12 para saber o mês correspondente:');
    String? input = stdin.readLineSync();

    int numero;
    if (input == null) {
        print('Entrada inválida. Por favor, insira um número válido.');
        solicitarNumero();
        return;
    }

    numero = int.parse(input);

    String mes = obterMes(numero);
    print(mes);

    if (mes == 'Número inválido. Por favor, insira um número de 1 a 12.') {
        solicitarNumero();
    }
}

// Função que retorna o mês correspondente
String obterMes(int numero) {
    switch (numero) {
        case 1:
            return 'Janeiro';
        case 2:
            return 'Fevereiro';
        case 3:
            return 'Março';
        case 4:
            return 'Abril';
        case 5:
            return 'Maio';
        case 6:
            return 'Junho';
        case 7:
            return 'Julho';
        case 8:
            return 'Agosto';
        case 9:
            return 'Setembro';
        case 10:
            return 'Outubro';
        case 11:
            return 'Novembro';
        case 12:
            return 'Dezembro';
        default:
            return 'Número inválido. Por favor, insira um número de 1 a 12.';
    }
}
```

04. Criando a função de depósito e fazendo sua validação.
```dart
import 'dart:io';

void main() {
    List<String> operacoes = ['deposito', 'retirada', 'transferencia', 'pagamento'];
    String? operacao;

    operacao = validaOperacao(operacao, operacoes);

    double? valor;

    valor = validaValor(valor);

    print('Operação escolhida: $operacao, Valor: $valor');
}

double? validaValor(double? valor) {
    print('Digite o valor da operação:');
    valor = double.tryParse(stdin.readLineSync()!);

    if (valor == null || valor <= 0) {
        print('Valor inválido. Tente novamente.');
        return validaValor(valor);
    } else {
        return valor;
    }
}

String? validaOperacao(String? operacao, List<String> operacoes) {
    print('Digite uma operação (deposito, retirada, transferencia, pagamento):');
    operacao = stdin.readLineSync();

    if (operacoes.contains(operacao)) {
        return operacao;
    } else {
        print('Operação inválida. Tente novamente.');
        return validaOperacao(operacao, operacoes);
    }
}
```

05. Validação de métodos de pagamento em uma plataforma de e-commerce.
```dart
import 'dart:io';

void main() {
    List<String> pagamentos = ['pix', 'boleto', 'cartao', 'paypal'];
    String? pagamento;

    pagamento = validaPagamento(pagamento, pagamentos);

    print('Pagamento válido: $pagamento');
}

String? validaPagamento(String? pagamento, List<String> pagamentos) {
    print('Digite o tipo de pagamento (pix, boleto, cartao, paypal):');
    pagamento = stdin.readLineSync();
    if (pagamentos.contains(pagamento)) {
        return pagamento;
    } else {
        print('Pagamento inválido. Tente novamente.');
        return validaPagamento(pagamento, pagamentos);
    }
}
```