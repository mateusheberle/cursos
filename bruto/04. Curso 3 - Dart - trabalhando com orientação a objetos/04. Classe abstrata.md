# 04. Classe abstrata

## Produzindo um molde com classe abstrata

**bin/anybank.dart**

```dart
import '../lib/conta.dart';

void main() {

    ContaCorrente contaChris = ContaCorrente("Chris", 4000);
    ContaPoupanca contaDenise = ContaPoupanca("Denise", 4000);

    contaChris.imprimeSaldo();
    contaChris.enviar(4300);
    
    contaDenise.imprimeSaldo();
    contaDenise.enviar(4300);
    contaDenise.calculaRendimento();
    contaDenise.imprimeSaldo();

}
```

**lib/conta.dart**

```dart
abstract class Conta {

    String titular;
    double _saldo;

    Conta(this.titular, this._saldo);

    void receber(double valor) {
        _saldo += valor;
        imprimeSaldo();
    }

    void enviar(double valor) {
        if (_saldo >= valor) {
            _saldo -= valor;
            imprimeSaldo();
        }
    }

    void imprimeSaldo() {
        print("O saldo atual de $titular, é R\$$_saldo");
    }

}

class ContaCorrente extends Conta {

    double emprestimo = 300;

    ContaCorrente(super.titular, super._saldo);

    @override
    void enviar(double valor) {
        if (_saldo + emprestimo >= valor) {
            _saldo -= valor;
            imprimeSaldo();
        }
    }
}

class ContaPoupanca extends Conta {

    double rendimento = 0.05;

    ContaPoupanca(super.titular, super._saldo);

    void calculaRendimento() {
        _saldo += _saldo * rendimento;
    }
}
```
```dart
O saldo atual de Chris, é R$4000
O saldo atual de Chris, é R$-300
O saldo atual de Denise, é R$4000
O saldo atual de Denise, é R$4200
```

### Classes abstratas

* **Não podem ser instanciadas**.
* **Servem apenas como base** para outras classes implementarem propriedades e funcionalidades.

```dart
abstract class Conta {

    String titular;
    double _saldo;
    ...

}
```

## Para saber mais: mais sobre classes abstratas

* Podemos pensar em uma **classe abstrata** como um **esqueleto** de uma classe.
* Servem como **modelos para outras classes**, definindo uma estrutura em comum. 
* São úteis para **criar hierarquias de classes** e garantir que as subclasses implementem determinadas funcionalidades.
* Ele define uma estrutura básica **como um guia**, com propriedades e métodos, mas não pode ser instanciada diretamente.
* Métodos abstratos são declarados com a palavra-chave `abstract`.
* **Subclasses devem implementar todos os métodos abstratos** da superclasse.
* Uma classes abstrata pode ter métodos com implementações próprias que podem ser sobrescritas em outras classes (embora não seja o uso mais indicado).
    

        Você não pode criar um objeto a partir de uma classe abstrata.

### Por que usar classes abstratas?

* Definimos um **"contrato"** que as subclasses devem seguir, garantindo que **todas as classes que herdam dela tenham as mesmas funcionalidades e propriedades**.
* Incentivamos também o **polimorfismo** permitindo que objetos de diferentes classes sejam tratados como se fossem de uma classes abstrata mãe.

### Exemplo:
```dart
abstract class Figura {

    double calcularArea();

}

class Circulo extends Figura {

    double raio;

    Circulo(this.raio);

    @override
    double calcularArea() {
        return 3.14159 * raio * raio;
    }

}

class Quadrado extends Figura {

    double lado;

    Quadrado(this.lado);

    @override
    double calcularArea() {
        return lado * lado;
    }

}
```
```dart
void main() {

    Circulo circulo = Circulo(5);
    Quadrado quadrado = Quadrado(4);

    print('Área do círculo: ${circulo.calcularArea()}');
    print('Área do quadrado: ${quadrado.calcularArea()}');

}
```
```dart
Área do círculo: 78.53975
Área do quadrado: 16
```

## Aprofundando classes abstratas e entendendo interface no Dart

### O que é classe abstrata em POO?

* **Classe** que não é instanciada.
* **Planta de construção** para outras classes.
* **Referência** para que outros objetos existam.
* **Não forma nada** por si só.

### Interface

* **Também** não pode ser instanciada.
* **Guia de métodos** a ser implementados.

**`extends`**: Herança.
**`implements`**: Interface.

```dart
abstract class Pontuacao {

    void calculaPontos();
    void devolveColocacao();

}

class Volei extends Esporte implements Pontuacao {

    Volei(super.time);

    @override
    void calculaPontos() {
        ...
    }
    
    @override
    void devolveColocacao() {
        ...
    }

}

abstract class Esporte {

    String time;

    Esporte(this.time);

}
```

## Para saber mais: mais sobre classe abstrata e interface 

### 01. O que é classe abstrata?

* Uma classe que não pode ser instanciada, ou seja, você **não pode criar um objeto a partir de uma classe abstrata**.
* Você pode utilizar uma classe abstrata reaproveitando-a dentro de outras classes comuns (com herança e polimorfismo).
* Classes abstrata funciona como um molde para que outras classes comuns reaproveitem os atributos e métodos da classe abstrata.

### 02. O que é interface?

* **Define padrões** que uma classe deve cumprir.
* Ela especifica **quais métodos e propriedades que uma classe deve ter**, sem se preocupar com a implementação.

#### Por que usar interfaces?

* **Polimorfismo**: Cada classe que usa uma interface precisa implementar da sua própria maneira os métodos da interface.
* **Desacoplamento**: A interface aumenta o desacoplamento entre as classes (separação de responsabilidades), o que deixa o código mais flexível e fácil de manter. 

#### Exemplo:

```dart
abstract class Figura {

    double calcularArea();

}

class Circulo implements Figura {

    double raio;

    Circulo(this.raio);

    @override
    double calcularArea() {
        return 3.14159 * raio * raio;
    }

}

class Quadrado implements Figura {

    double lado;

    Quadrado(this.lado);

    @override
    double calcularArea() {
        return lado * lado;
    }

}
```
```dart
void main() {

    List<Figura> figuras = [Circulo(5), Quadrado(4)];

    for (var figura in figuras) {
        print('Área: ${figura.calcularArea()}');
    }

}
```
```dart
Área: 78.53975
Área: 16
```

#### Importante:

* **Uma classe pode implementar várias interfaces**.
* Os métodos em uma interface são implicitamente abstratos (não precisam ser implementados na sua declaração).
* Uma classe pode herdar (`extends`) outra classe e implementar (`implements`) uma interface.
* Por mais que sejam parecidas com classes abstratas, interfaces não podem ter implementações de seus métodos, eles precisam acontecer na classe que faz o `implements`.

## Lista de exercícios

### 01. Refatorando o código das classes gato e cachorro

Considerando o exercício anterior, “Criando classes de gato e cachorro” em que foi solicitada a criação das classes `Animal`, `Gato` e `Cachorro` (e o método `emitirSom()`), refatore a classe `Animal`, transformando-a em uma classe abstrata.

    Lembre-se de que reescrever e refatorar código é uma atividade comum no dia a dia de uma pessoa desenvolvedora. Logo, é importante que você pratique essa atividade.

### 01. Resposta
```dart
// Classe base Animal
abstract class Animal {

    void emitirSom() {
        print("O animal emitiu um som.");
    }

}

// Classe Cachorro que herda de Animal
class Cachorro extends Animal {

    @override
    void emitirSom() {
        print("O cachorro late.");
    }

    void abanarRabo() {
        print("O cachorro está abanando o rabo.");
    }

}

// Classe Gato que herda de Animal
class Gato extends Animal {

    @override
    void emitirSom() {
        print("O gato miou.");
    }

    void arranharMoveis() {
        print("O gato está arranhando os móveis.");
    }

}

void main() {

    // Instanciando as classes e chamando os métodos
    Cachorro cachorro = Cachorro();
    Gato gato = Gato();

    cachorro.emitirSom(); // O cachorro late.
    cachorro.abanarRabo(); // O cachorro está abanando o rabo.

    gato.emitirSom(); // O gato miou.
    gato.arranharMoveis(); // O gato está arranhando os móveis.

}
```

### 02. Refatorando o código das reservas em hotel

Se você fez os exercícios da aula passada referentes às classes `quartoSimples`, `quartoMedio` e `quartoLuxo`, refatore o código que você escreveu, agora adicionando uma classe abstrata `quarto` da qual as demais classes herdam características e aplicam o polimorfismo.

Refatore o código e reflita o porquê utilizamos uma classe abstrata nesse caso.

### 02. Resposta
```dart
void main() {

    QuartoSimples quartoSimples = QuartoSimples(3);
    quartoSimples.reservar();
    quartoSimples.calcularValorTotal();
    QuartoMedio quartoMedio = QuartoMedio(5);
    quartoMedio.reservar();
    quartoMedio.servirCafeDaManha();
    quartoMedio.calcularValorTotal();
    QuartoLuxo quartoLuxo = QuartoLuxo(7);
    quartoLuxo.reservar();
    quartoLuxo.servirCafeDaManha();
    quartoLuxo.servicoDeQuarto();
    quartoLuxo.calcularValorTotal();

}

abstract class Quarto {

    String tipo;
    double valorDiaria;
    int diarias;

    Quarto(this.diarias, this.valorDiaria, this.tipo);

    void reservar() {
        print("Reserva realizada para $diarias diarias no quarto $tipo.");
    }

    void calcularValorTotal() {
        print("Total a pagar: R\$${diarias * valorDiaria}");
    }

}

class QuartoSimples extends Quarto {

    QuartoSimples(int diarias) : super(diarias, 80, 'Simples');

}

class QuartoMedio extends Quarto {

    QuartoMedio(int diarias) : super(diarias, 250, 'Médio');

    void servirCafeDaManha() {
        print("Servindo cafe da manha no quarto $tipo.");
    }

}

class QuartoLuxo extends Quarto {

    QuartoLuxo(int diarias) : super(diarias, 1000, 'Luxo');

    void servirCafeDaManha() {
        print("Servindo cafe da manha no quarto $tipo.");
    }

    void servicoDeQuarto() {
        print("Limpando quarto $tipo.");
    }

}
```

### 03. Refatorando o código dos ingredientes

É importante que você tenha feito o exercício de ingredientes e receitas da aula anterior.

Refatore o código do exercício, agora transformando a classe `ingrediente` em uma classe abstrata, fazendo as modificações necessárias e mantendo os padrões de herança e polimorfismo aplicados ao código.

### 03. Resposta
```dart
// Classe base Ingrediente
abstract class Ingrediente {

    String nome;
    String tipo;

    Ingrediente(this.nome, this.tipo);

    void detalhes() {
        print('Ingrediente: $nome');
        print('Tipo: $tipo');
    }

}

// Classe Fruta, que herda de Ingrediente
class Fruta extends Ingrediente {

    Fruta(String nome) : super(nome, 'Fruta');

    @override
    void detalhes() {
        print('Detalhe: As frutas geralmente não são cozidas nas receitas.');
    }

}

// Classe Legume, que herda de Ingrediente
class Legume extends Ingrediente {

    Legume(String nome) : super(nome, 'Legume');

    @override
    void detalhes() {
        print('Detalhe: Os legumes geralmente precisam ser cozidos nas receitas.');
    }

}

// Classe Tempero, que herda de Ingrediente
class Tempero extends Ingrediente {

    Tempero(String nome) : super(nome, 'Tempero');

    @override
    void detalhes() {
        print('Detalhe: Os temperos são usados para condimentar os alimentos.');
    }

}

void main() {

    // Criando instâncias de frutas, legumes e temperos
    var banana = Fruta('Banana');
    var cenoura = Legume('Cenoura');
    var sal = Tempero('Sal');

    // Exibindo os detalhes
    banana.detalhes();
    print('');
    cenoura.detalhes();
    print('');
    sal.detalhes();

}
```

### 04. Corrigindo um código com bugs

O código a seguir deveria imprimir no terminal que um documento do tipo relatório foi impresso. No entanto, por algum motivo, o código não funciona. Analise-o com atenção:

```dart
abstract class Documento {
    
    String nomeDoDocumento;

    Documento(this.nomeDoDocumento);

    void imprimir() {
        print('O ${relatorio.nomeDoDocumento} foi enviado para impressão');
    }

}

void main() {

    Documento relatorio = Documento('Relatório Anual');
    relatorio.imprimir();

}
```

Identifique os erros e corrija o código, considerando o que aprendemos sobre classe abstrata em Dart. Atenção: a classe abstrata `Documento` deve permanecer uma classe abstrata, pois deve funcionar como molde para outros documentos como "relatório", "planilha" etc. Pense em formas de solucionar esse problema sem transformar a classe abstrata em uma classe comum.

### 04. Resposta
```dart
// Código corrigido
abstract class Documento {
    
    String nomeDoDocumento;
    
    Documento(this.nomeDoDocumento);

    void imprimir();

}

class Relatorio extends Documento {
    
    Relatorio(String nomeDoDocumento) : super(nomeDoDocumento);
    
    @override
    void imprimir() {
        print('O $nomeDoDocumento foi enviado para impressão');
    }

}

void main() {
   
    Documento relatorio = Relatorio('Relatório Anual'); // Correção: Instanciando a classe concreta
    relatorio.imprimir();

}
```

### 05. Criando um programa de registro de funcionários

Primeiro, crie uma classe abstrata `funcionario` com os atributos nome de funcionário(a) e um double “salário base” inicializado em 3000 reais, e também um método `calcularSalario`. Em seguida, implemente, a partir de `funcionario`, as classes `analista`, `gerente` e `diretor`; sobrescreva o método `calcularSalario` nelas com os seguintes valores:

* `Analista`: salário base = salário base + salário base multiplicado por 1.2;
* `Gerente`: salário base = salário base + salário base multiplicado por 1.5;
* `Diretor`: salário base = salário base + salário base multiplicado por 2.0.

Por fim, imprima o cálculo de salário dos funcionários João (analista), Maria (gerente) e Giovana (diretora), conforme o exemplo a seguir:

```dart
Salário do Analista João: R$ 6600.0
Salário da Gerente Maria: R$ 7500.0   
Salário da Diretora Giovana: R$ 9000.0
```

### 05. Resposta

```dart
// Classe abstrata Funcionario
abstract class Funcionario {
    
    String nome;
    double salarioBase;

    Funcionario(this.nome) : salarioBase = 3000.0; // Salário base inicializado em 3000 reais

    // Método abstrato para ser implementado nas subclasses
    double calcularSalario();

}

// Classe Analista que herda de Funcionario
class Analista extends Funcionario {

    Analista(String nome) : super(nome);

    @override
    double calcularSalario() {
        return salarioBase + (salarioBase * 1.2);
    }

}

// Classe Gerente que herda de Funcionario
class Gerente extends Funcionario {

    Gerente(String nome) : super(nome);

    @override
    double calcularSalario() {
        return salarioBase + (salarioBase * 1.5);
    }

}

// Classe Diretor que herda de Funcionario
class Diretor extends Funcionario {

    Diretor(String nome) : super(nome);

    @override
    double calcularSalario() {
        return salarioBase + (salarioBase * 2.0);
    }

}

void main() {

    // Instâncias das classes para os funcionários
    Funcionario joao = Analista('João');
    Funcionario maria = Gerente('Maria');
    Funcionario giovana = Diretor('Giovana');

    // Impressão dos cálculos de salário
    print('Salário do Analista João: R\$ ${joao.calcularSalario()}');
    print('Salário da Gerente Maria: R\$ ${maria.calcularSalario()}');
    print('Salário da Diretora Giovana: R\$ ${giovana.calcularSalario()}');

}
```

### 06. Criando um programa informativo de espécies de seres vivos

Este exercício será um pouco mais desafiador.

* Crie um programa que mostra características sobre os seres vivos e implemente três classes, seguindo os requisitos de cada uma:
* Classe `SerVivo`: será uma classe abstrata que terá um método `void mostrarCaracteristicas()`;.
* **Planta**: será uma classe que implementa `SerVivo` e terá os seguintes objetos e suas descrições de print:
  * Girassol: é uma planta, não tem os cinco sentidos, é uma flor;
  * Laranjeira: é uma planta, não tem os cinco sentidos, é uma árvore;
* **Animal**: é vivo e tem os cinco sentidos:
  * Ser humano: tem cinco sentidos, pensa e fala, é bípede e vive em média 75 anos;
  * Gato: tem cinco sentidos, mia, é quadrúpede e vive em média 20 anos;
  * Cão: tem cinco sentidos, late, é quadrúpede e vive em média 20 anos.

Represente essas coisas do mundo real com classe, classe abstrata, herança e polimorfismo de orientação a objetos.

O resultado do print no terminal deverá se parecer com isto:

```dart
Girassol: é uma planta, não tem os cinco sentidos, é uma flor.
Laranjeira: é uma planta, não tem os cinco sentidos, é uma árvore.
Ser humano: tem cinco sentidos, pensa e fala, é bípede e vive em média 75 anos.
Gato: tem cinco sentidos, pensa e fala, é quadrúpede e vive em média 20 anos.
Cão: tem cinco sentidos, pensa e fala, é quadrúpede e vive em média 20 anos.
```

### 06. Resposta

```dart
abstract class SerVivo {
    
    String nome;
    String tipo;

    SerVivo(this.nome, this.tipo);

    void mostrarCaracteristicas();

}

class Planta extends SerVivo {

    Planta(String nome, String tipo) : super(nome, tipo);

    @override
    void mostrarCaracteristicas() {
        print('$nome: é uma planta, não tem os cinco sentidos, é uma $tipo');
    }

}

class Animal extends SerVivo {
    
    int tempoVida;

    Animal(String nome, String tipo, this.tempoVida) : super(nome, tipo);

    @override
    void mostrarCaracteristicas() {
        print('$nome: tem cinco sentidos, pensa e fala, é $tipo e vive em média $tempoVida anos');
    }

}

void main() {
    
    Planta girassol = Planta('Girassol', 'flor');
    girassol.mostrarCaracteristicas();
    Planta laranjeira = Planta('Laranjeira', 'árvore');
    laranjeira.mostrarCaracteristicas();

    Animal humano = Animal('Ser humano', 'bípede', 75);
    humano.mostrarCaracteristicas();
    Animal gato = Animal('Gato', 'quadrúpede', 20);
    gato.mostrarCaracteristicas();
    Animal cao = Animal('Cão', 'quadrúpede', 20);
    cao.mostrarCaracteristicas();

}
```


### 07. Definindo a interface para agendamento

Crie uma interface chamada `Agendamento` que inclua os métodos `calculaDuracaoConsulta()` e `verificaDisponibilidade()`. Esses métodos devem ser abstratos e servem como base para diferentes tipos de profissionais de saúde implementarem suas regras de agendamento.

Você não precisa exibir nada no terminal! Apenas crie o código com a estrutura da interface.

### 07. Resposta

```dart
abstract class Agendamento {
    
    void calculaDuracaoConsulta();
    void verificaDisponibilidade();

}
```

### 08. Implementando a interface em uma classe de médico

Implemente a interface `Agendamento` na classe `Medico`. A classe `Medico` deve fornecer uma implementação concreta dos métodos `calculaDuracaoConsulta()` e `verificaDisponibilidade()`. Considere que, para médicos, a duração padrão da consulta é de 30 minutos, e a disponibilidade é verificada com base em um calendário de agendamentos previamente existente.

### 08. Resposta

```dart
class Medico implements Agendamento {
    
    @override
    void calculaDuracaoConsulta() {
        // Implementação: duração padrão de 30 minutos
        print("duração de 30 minutos");
    }

    @override
    void verificaDisponibilidade() {
        // Implementação: verificar disponibilidade no calendário
        print("verificar disponibilidade no calendário");
    }

}
```
### 09. Implementando a interface em uma classe de dentista

Adicione um novo tipo de profissional ao sistema criando uma classe `Dentista` que também implementa a interface `Agendamento`. Defina a implementação do método `calculaDuracaoConsulta()` considerando que as consultas odontológicas duram 45 minutos. No método `verificaDisponibilidade()`, implemente a lógica para verificar a disponibilidade, considerando que os dentistas têm intervalos de 15 minutos entre consultas.

### 09. Resposta

```dart
class Dentista implements Agendamento {
    
    @override
    void calculaDuracaoConsulta() {
        // Implementação: duração de 45 minutos
        print("duração de 45 minutos");
    }

    @override
    void verificaDisponibilidade() {
        // Implementação: verificar disponibilidade considerando intervalos de 15 minutos
        print("verificar disponibilidade considerando intervalos de 15 minutos");
    }

}
```

### 10. Criando um gerenciador de agendamentos de consulta

Crie uma classe chamada `GerenciadorDeAgendamentos` que contenha uma lista de objetos que implementam a interface Agendamento. Adicione métodos para adicionar novos profissionais à lista e para calcular e exibir a duração das consultas e a disponibilidade de todos os profissionais cadastrados no sistema.

A ideia aqui não é exibir nada no terminal, apenas praticar a lógica do código. Portanto, não se preocupe em instanciar ou criar objetos. Foque apenas na lógica da classe `GerenciadorDeAgendamentos` e seus métodos.

### 10. Resposta

```dart
class GerenciadorDeAgendamentos {
    
    List<Agendamento> profissionais = [];

    void adicionarProfissional(Agendamento profissional) {
        profissionais.add(profissional);
    }

    void exibirDuracaoEDisponibilidade() {
        for (Agendamento profissional in profissionais) {
            profissional.calculaDuracaoConsulta();
            profissional.verificaDisponibilidade();
        }
    }

}
```

### 11. Testando o sistema de agendamento

Implemente um código de teste onde você cria instâncias das classes `Medico` e `Dentista`, adiciona essas instâncias ao `GerenciadorDeAgendamentos`, e chama os métodos para calcular e exibir a duração das consultas e verificar a disponibilidade para novos agendamentos. Verifique se o sistema está funcionando conforme o esperado.

### 11. Resposta

```dart
void main() {

    Medico medico = Medico();
    Dentista dentista = Dentista();

    GerenciadorDeAgendamentos gerenciador = GerenciadorDeAgendamentos();
    gerenciador.adicionarProfissional(medico);
    gerenciador.adicionarProfissional(dentista);

    gerenciador.exibirDuracaoEDisponibilidade();
    
}
```