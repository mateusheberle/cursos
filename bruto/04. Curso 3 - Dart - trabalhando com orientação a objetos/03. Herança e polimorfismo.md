# Herança e polimorfismo

## Reaproveitando código com herança

Tarefa: criar 2 novos tipos de contas, a conta corrente e a conta poupança.

**bin/anybank.dart**

```dart
import '../lib/conta.dart';

void main() {

    Conta contaMateus = Conta("Mateus", 1000);
    Conta contaRoberta = Conta("Roberta", 2000);

    ContaCorrente contaChris = ContaCorrente("Chris", 4000);
    ContaPoupanca contaDenise = ContaPoupanca("Denise", 4000);

    /*
    List<Conta> contas = <Contas>[contaMateus, contaRoberta];

    for (Conta conta in contas) {
        conta.imprimeSaldo();
    }

    contaRoberta.receber(3000);
    contaMateus.receber(500);
    contaMateus.enviar(200);
    */

    contaChris.imprimirSaldo();
    contaChris.receber(100);
    
    contaDenise.imprimirSaldo();
    contaDenise.enviar(300);

}
```

**lib/conta.dart**

```dart
class Conta {

    String titular;
    double _saldo;

    Conta(this.titular, this._saldo);

    void receber(double valor) {
        _saldo += valor;
        imprimeSaldo();
    }

    void enviar(double valor) {
        if (_saldo >= valor) {
            _saldo -= valor;
            imprimeSaldo();
        }
    }

    void imprimeSaldo() {
        print("O saldo atual de $titular, é R\$$_saldo");
    }

}

class ContaCorrente extends Conta {
    ContaCorrente(super.titular, super._saldo);
}

class ContaPoupanca extends Conta {
    ContaPoupanca(super.titular, super._saldo);
}
```

    Quando há repetição de código, pode haver algo errado.

Para indicar que `ContaCorrente` e `ContaPoupanca` compartilham características com a classe `Conta`, usa-se a palavra-chave **`extends`**.

**`super`**: Referenciar uma propriedade de uma classe que estamos tentando implementar dentro de outra classe.

```dart
class ContaCorrente extends Conta {
    ContaCorrente(super.titular, super._saldo);
}

class ContaPoupanca extends Conta {
    ContaPoupanca(super.titular, super._saldo);
}
```

* **Todas as propriedades e métodos** da classe `Conta` foram acessadas nas classes `ContaCorrente` e `ContaPopupanca`.

* `extends Conta`: Processo de **herança**.
  * Permite que uma classe **herde propriedades, atributos e métodos** de outra classe.

## Para saber mais: outras formas de chamar superclasse

2 formas comuns para instanciar atributos da superclasse em subclasses.

```dart
class Animal {

    String nome;

    Animal(this.nome);

    void comer() {
        print('$nome está comendo.');
    }

}

class Cachorro extends Animal {

    String cor;

    Cachorro(this.cor);

    void latir() {
        print('$nome está latindo.');
    }

}
```

### 1ª forma:

```dart
class Cachorro extends Animal {

    String cor;

    Cachorro(this.cor, super.nome);
    
    void latir() {
        print('$nome está latindo.');
    }

}
```

### 2ª forma: 

```dart
class Cachorro extends Animal {

    String cor;

    Cachorro(this.cor, String nome): super(nome);

    void latir() {
        print('$nome está latindo.');
    }

}
```

## Diferenciando classes com polimorfismo

**bin/anybank.dart**

```dart
import '../lib/conta.dart';

void main() {

    Conta contaMateus = Conta("Mateus", 1000);
    Conta contaRoberta = Conta("Roberta", 2000);

    ContaCorrente contaChris = ContaCorrente("Chris", 4000);
    ContaPoupanca contaDenise = ContaPoupanca("Denise", 4000);

    contaChris.imprimirSaldo();
    contaChris.enviar(4300);
    
    contaDenise.imprimirSaldo();
    contaDenise.enviar(4300);
    contaDenise.calculaRendimento();
    contaDenise.imprimirSaldo();

}
```

**lib/conta.dart**

```dart
class Conta {

    String titular;
    double _saldo;

    Conta(this.titular, this._saldo);

    void receber(double valor) {
        _saldo += valor;
        imprimeSaldo();
    }

    void enviar(double valor) {
        if (_saldo >= valor) {
            _saldo -= valor;
            imprimeSaldo();
        }
    }

    void imprimeSaldo() {
        print("O saldo atual de $titular, é R\$$_saldo");
    }

}

class ContaCorrente extends Conta {

    double emprestimo = 300;

    ContaCorrente(super.titular, super._saldo);

    @override
    void enviar(double valor) {
        if (_saldo + emprestimo >= valor) {
            _saldo -= valor;
            imprimeSaldo();
        }
    }
}

class ContaPoupanca extends Conta {

    double rendimento = 0.05;

    ContaPoupanca(super.titular, super._saldo);

    void calculaRendimento() {
        _saldo += _saldo * rendimento;
    }
}
```

**Herança**: É a capacidade de uma classe transmitir seus atributos e métodos para outra classe.

No caso em questão, `ContaCorrente()` e `ContaPoupanca()` herdam as propriedades `titular` e `saldo`, além dos métodos de `enviar()`, `receber()` e `imprimeSaldo()` da classe `Conta`.

Sobrescrita do método `enviar()`: 

```dart
@override
void enviar() {}
```

## Mão na massa: a equipe do bistrô

O bistrô está contratando novos funcionários e você precisa criar um sistema para gerenciar a equipe. Existem três tipos de funcionários: cozinheiros, garçons e gerentes. Cada funcionário possui um nome e um salário.

```dart
class Funcionario {
    String nome;
    double salario;

    Funcionario(this.nome, this.salario);
}

class Cozinheiro extends Funcionario {
    // ...
}

class Garcom extends Funcionario {
    // ...
}

class Gerente extends Funcionario {
    // ...
}
```

Você precisa criar um método trabalhar que imprima uma mensagem diferente para cada tipo de funcionário, indicando o que ele faz.

```dart
class Funcionario {

    String nome;
    double salario;

    Funcionario(this.nome, this.salario);

    void trabalhar() {
        print("$nome trabalhou");
    }

}

class Cozinheiro extends Funcionario {

    Cozinheiro(super.nome, super.salario);

    @override
    void trabalhar() {
        print("$nome trabalhou na cozinha");
    }

}

class Garcom extends Funcionario {

    Garcom(super.nome, super.salario);

    @override
    void trabalhar() {
        print("$nome trabalhou no atendimento");
    }

}

class Gerente extends Funcionario {

    Gerente(super.nome, super.salario);

    @override
    void trabalhar() {
        print("$nome gerenciou a equipe");
    }

}
```

## Aprofundando em herança e polimorfismo

### Herança e polimorfismo

- **Herança**: É a capacidade de uma coisa **herdar características de outra**.
  - *Exemplo*: herdar características dos pais.

- **Polimorfismo**: É a capacidade de uma classe ou objeto de **ter diferentes formas**.
  - *Exemplo* de um animal: pássaro voa a cobra rasteja.
  
#### Palavras reservadas: 
- **`extends`**: Usamos para especificar a classe da qual queremos herdar propriedades e métodos.
- **`super`**: Fazer referência aos atributos da classe que estamos herdando (classe pai).
  - `this`: Referencia os atributos da classe atual. 
- **`@override`**: Uma notação está sendo sobrescrita.

**Classe Animal**

```dart
class Animal {

    String nomeCientifico;
    int idade;

    void locomover() {
        print("Estou me locomovendo");
    }

}

class Passaro extends Animal {

    Passaro(super.nomeCientifico, super.idade);

    @override
    void locomover() {
        print("Estou voando!");
    }

}

class Cobra extends Animal {

    Cobra(super.nomeCientifico, super.idade);

    @override
    void locomover() {
        print("Estou rastejando!");
    }

    void trocarDePele(){}

}
```

## Para saber mais: mais exemplos de herança e polimorfismo

### 1. O que é herança?

**Herança** é uma forma de criar novas classes (**subclasses ou filhas**) a partir de classes já existentes (**superclasses ou mães**). Essa nova classe herda todos os atributos e métodos da classe mãe (ou superclasse), podendo adicionar novos ou sobrescrever os existentes.

### 2. Por que usar herança?

* **Evitamos a reescrita** de código comum a diferentes classes.
* Criamos uma estrutura de hierarquia entre as classes, o que **organiza o código**.

### Exemplo de "animais":

```dart
class Animal {

    String nome;

    Animal(this.nome);

    void comer() {
        print('$nome está comendo.');
    }

}

class Cachorro extends Animal {

    Cachorro(super.nome);

    void latir() {
        print('$nome está latindo.');
    }

}

class Gato extends Animal {

    Gato(super.nome);

    void miar() {
        print('$nome está miando.');
    }

}
```

* Classe **`Animal`**:
  * É a classe base (superclasse).
  * Possui um atributo `nome` e um método `comer()`.

* Classe **`Cachorro`**:
  * **Herda** o atributo (`nome`) e o método (`comer()`) da classe `Animal`.
  * Possui um método específico `latir()`.

* Classe **`Gato`**:
  * **Herda** o atributos e o método da classe `Animal`;
  * Possui um método específico `miar()`.

* As duas classes precisam inicializar dentro de seus construtores os atributos da superclasse:
  * Classe `Cachorro` usa `Cachorro(super.nome)`;
  * Classe `Gato` usa `Gato(super.nome)`.

### Como instanciar:

```dart
void main() {

    Cachorro cachorro = Cachorro('Rex');
    cachorro.comer(); // Imprime: Rex está comendo.
    cachorro.latir(); // Imprime: Rex está latindo.

    Gato gato = Gato('Mia');
    gato.comer(); // Imprime: Mia está comendo.
    gato.miar(); // Imprime: Mia está miando.

}
```

## Lista de exercícios

### 01. Criando classes de gatos e cachorros

Crie uma classe `Animal` com um método `emitirSom()`. Em seguida, crie duas outras classes: `Cachorro` e `Gato`, que herdam o método da classe `Animal`. Ao adicionar o método `emitirSom()` nas classes `Cachorro` e `Gato`, utilize a anotação `@override` para indicar que estão sobrescrevendo o método — o método `emitirSom` deve fazer um print "O cachorro late" para `Cachorro` e "o gato miou" para `Gato`.

Além disso, adicione métodos específicos para cada classe, como `abanarRabo()` para o `Cachorro` e `arranharMoveis()` para o `Gato`.

O print no terminal deve ser semelhante a isto:
```dart
O cachorro late.
O cachorro está abanando o rabo. 
O gato miou.
O gato está arranhando os móveis.
```

### 01. Resposta
```dart
// Classe base Animal
class Animal {

    void emitirSom() {
        print("O animal emitiu um som.");
    }

}

// Classe Cachorro que herda de Animal
class Cachorro extends Animal {

    @override
    void emitirSom() {
        print("O cachorro late.");
    }

    void abanarRabo() {
        print("O cachorro está abanando o rabo.");
    }

}

// Classe Gato que herda de Animal
class Gato extends Animal {

    @override
    void emitirSom() {
        print("O gato miou.");
    }

    void arranharMoveis() {
        print("O gato está arranhando os móveis.");
    }

}

void main() {

    // Instanciando as classes e chamando os métodos
    Cachorro cachorro = Cachorro();
    Gato gato = Gato();

    cachorro.emitirSom(); // O cachorro late.
    cachorro.abanarRabo(); // O cachorro está abanando o rabo.

    gato.emitirSom(); // O gato miou.
    gato.arranharMoveis(); // O gato está arranhando os móveis.

}
```


### 02. Produzindo uma conta salário com herança

Continuando o projeto Any Bank, é hora de criar um terceiro tipo de conta: a **conta salário**. Assim como as classes conta corrente e conta poupança, ela possui duas características essenciais: o `titular` e o `saldo`.

Escreva o código da classe `ContaSalario` e um objeto de conta salário de uma pessoa chamada Catarina (ou qualquer nome que você desejar). Se quiser, imprima o saldo da pessoa no terminal.

Dicas:

Crie o código da classe `ContaSalario` e faça a instanciação do objeto `contaSalarioCatarina`;
Empregue a técnica de **herança** para evitar a repetição de código;
Apenas declare a classe. Não é preciso fazer nada além disso.

### 02. Resposta
```dart
class ContaSalario extends Conta {
    ContaSalario(super.titular, super._saldo);
}
```

### 03. Incrementando a conta salário com polimorfismo

Agora, vamos melhorar a classe da conta salário. Você deve saber que a `contaSalario` tem duas características em comum com as contas corrente e poupança: `titular` e `saldo`. No entanto, ela apresenta três características **diferentes**:

* Variável com o CNPJ da empresa que emprega o(a) titular da conta;
* Variável do nome da empresa;
* Um método (função `print`) que diz algo como: "O salário da \$empresa, de CNPJ X no valor de R\$xx.x, foi depositado!"
Aplique essas três características na classe contaSalario!

Dica:

* Aplique a técnica de **polimorfismo** para diferenciar a conta salário das contas corrente e poupança.

### 03. Resposta
```dart
class ContaSalario extends Conta {
    String cnpjEmpresa;
    String nomeEmpresa;

    ContaSalario(super.titular, super._saldo, this.cnpjEmpresa, this.nomeEmpresa);

    void depositarSalario(double valor) {
        _saldo += valor;
        print("O salário da $nomeEmpresa, de CNPJ $cnpjEmpresa no valor de R\$$valor foi depositado!");
    }

}

void main() {
    ContaSalario contaSalarioCatarina = ContaSalario("Catarina", 5000, "123456789", "AnyBank");
    contaSalarioCatarina.depositarSalario(1000);
    contaSalarioCatarina.imprimeSaldo();
}
```


### 04. Representando quartos com herança

Crie três classes que representam três tipos de quartos em um hotel: quarto simples, quarto médio e quarto luxo. Todos os quartos têm em comum as seguintes características:

* **Tipo de quarto**: indica se o quarto é simples, médio ou luxo;
* **Valor da diária**: registra a diária do tipo do quarto. Por exemplo, a diária do quarto simples é 80 reais; a do quarto médio é 250 reais; a do quarto luxo é 1000 reais. Repare que todos possuem a característica valorDiaria em comum, que é reaproveitada nos três tipos de quarto;
* **Número de diárias**: o número de diárias reservadas por um(a) hóspede;
* **Método de reservar**: realiza a ação de reservar um quarto.

### 04. Resposta
```dart
void main() {

    QuartoSimples quartoSimples = QuartoSimples(3);
    quartoSimples.reservar();
    QuartoMedio quartoMedio = QuartoMedio(5);
    quartoMedio.reservar();
    QuartoLuxo quartoLuxo = QuartoLuxo(7);
    quartoLuxo.reservar();

}

class Quarto {

    String tipo;
    double valorDiaria;
    int diarias;

    Quarto(this.diarias, this.valorDiaria, this.tipo);

    void reservar() {
        print("Reserva realizada para $diarias diarias no quarto $tipo.");
    }

}

class QuartoSimples extends Quarto {

    QuartoSimples(int diarias) : super(diarias, 80, 'Simples');

}

class QuartoMedio extends Quarto {

    QuartoMedio(int diarias) : super(diarias, 250, 'Médio');

}

class QuartoLuxo extends Quarto {

    QuartoLuxo(int diarias) : super(diarias, 1000, 'Luxo');

}
```

### 05. Adicionando diferenças com polimorfismo

Agora que você criou as três classes de quartos, adicione as diferenças que existem entre elas:

* **Café da manhã**: apenas os quartos médio e luxo possuem esta comodidade. Implemente essa característica com método que contém um print como "Servindo café da manhã no quarto do $tipo";
* **Serviço de quarto**: exclusivo do quarto luxo. Crie um método print do serviço de quarto, como "Limpando o quarto $tipo."

### 05. Resposta
```dart
void main() {

    QuartoSimples quartoSimples = QuartoSimples(3);
    quartoSimples.reservar();
    QuartoMedio quartoMedio = QuartoMedio(5);
    quartoMedio.reservar();
    quartoMedio.servirCafeDaManha();
    QuartoLuxo quartoLuxo = QuartoLuxo(7);
    quartoLuxo.reservar();
    quartoLuxo.servirCafeDaManha();
    quartoLuxo.servicoDeQuarto();

}

class Quarto {

    String tipo;
    double valorDiaria;
    int diarias;

    Quarto(this.diarias, this.valorDiaria, this.tipo);

    void reservar() {
        print("Reserva realizada para $diarias diarias no quarto $tipo.");
    }

}

class QuartoSimples extends Quarto {

    QuartoSimples(int diarias) : super(diarias, 80, 'Simples');

}

class QuartoMedio extends Quarto {

    QuartoMedio(int diarias) : super(diarias, 250, 'Médio');

    void servirCafeDaManha() {
        print("Servindo cafe da manha no quarto $tipo.");
    }

}

class QuartoLuxo extends Quarto {

    QuartoLuxo(int diarias) : super(diarias, 1000, 'Luxo');

    void servirCafeDaManha() {
        print("Servindo cafe da manha no quarto $tipo.");
    }

    void servicoDeQuarto() {
        print("Limpando o quarto $tipo.");
    }

}
```

### 06. Criando um método de cálculo de diárias

Agora, cada tipo de quarto deve calcular o valor total da reserva com base em tarifas específicas. Você precisa ajustar as classes para lidar com essas tarifas.

Adicione um método `calcularValorTotal` nas classes `Quarto`, `QuartoMedio` e `QuartoLuxo`. O método deve calcular o valor total da reserva com base em uma tarifa diária específica para cada tipo de quarto. Na main, crie exemplos de reservas para os três tipos de quarto e mostre o valor total calculado.

### 06. Resposta
```dart
void main() {

    QuartoSimples quartoSimples = QuartoSimples(3);
    quartoSimples.reservar();
    quartoSimples.calcularValorTotal();
    QuartoMedio quartoMedio = QuartoMedio(5);
    quartoMedio.reservar();
    quartoMedio.servirCafeDaManha();
    quartoMedio.calcularValorTotal();
    QuartoLuxo quartoLuxo = QuartoLuxo(7);
    quartoLuxo.reservar();
    quartoLuxo.servirCafeDaManha();
    quartoLuxo.servicoDeQuarto();
    quartoLuxo.calcularValorTotal();

}

class Quarto {

    String tipo;
    double valorDiaria;
    int diarias;

    Quarto(this.diarias, this.valorDiaria, this.tipo);

    void reservar() {
        print("Reserva realizada para $diarias diarias no quarto $tipo.");
    }

    void calcularValorTotal() {
        print("Total a pagar: R\$${diarias * valorDiaria}");
    }
    
}

class QuartoSimples extends Quarto {
    
    QuartoSimples(int diarias) : super(diarias, 80, 'Simples');

}

class QuartoMedio extends Quarto {

    QuartoMedio(int diarias) : super(diarias, 250, 'Médio');

    void servirCafeDaManha() {
        print("Servindo cafe da manha no quarto $tipo.");
    }

}

class QuartoLuxo extends Quarto {
    
    QuartoLuxo(int diarias) : super(diarias, 1000, 'Luxo');

    void servirCafeDaManha() {
        print("Servindo cafe da manha no quarto $tipo.");
    }

    void servicoDeQuarto() {
        print("Limpando quarto $tipo.");
    }

}
```

### 07. Implementando uma classe de ingrediente

Considere que você precisa criar um programa que registra ingredientes de receitas e informações sobre eles. O primeiro passo é implementar a classe `Ingrediente`, que terá as seguintes características (atributos) e ações (métodos):

* `string nome`: armazena o nome de um ingrediente (por exemplo, cebola);
* `string tipo`: armazena o tipo de ingrediente (por exemplo, fruta, legume ou tempero).
* Método `detalhes()`: printa o nome e o tipo do ingrediente.

A ideia é apenas criar a classe. Não se preocupe em printar nada no terminal por enquanto!

### 07. Resposta
```dart
// Classe base Ingrediente
class Ingrediente {
    
    String nome;
    String tipo;

    Ingrediente(this.nome, this.tipo);

    void detalhes() {
        print('Ingrediente: $nome');
        print('Tipo: $tipo');
    }

}
```

### 8. Implementando as classes de tipos de ingrediente

Vamos continuar o programa de receitas. Agora que você concluiu a classe abstrata `Ingrediente`, vamos usá-la de molde para criar três classes de tipos de ingrediente:

* `Fruta`: em geral, são vegetais que não podem ser cozidos nas receitas;
* `Legume`: em geral, são vegetais que precisam ser cozidos;
* `Tempero`: são especiarias que condimentam os alimentos.

Ao criar as três classes, aplique a herança e polimorfismo. Sobrescreva o método `detalhes()` em cada uma das classes. Por exemplo, em `Fruta`, você pode inserir um print “em geral, são vegetais que não podem ser cozidos nas receitas” e assim por diante.

Por fim, crie os objetos `banana` (de Fruta), `cenoura` (de Legume) e `sal` (de Tempero) e os métodos para exibir suas informações e detalhes. O print no terminal pode ser algo assim:
```dart
Ingrediente: Banana
Tipo: Fruta
Detalhe: As frutas geralmente não são cozidas nas receitas.      

Ingrediente: Cenoura
Tipo: Legume
Detalhe: Os legumes geralmente precisam ser cozidos nas receitas.

Ingrediente: Sal
Tipo: Tempero
Detalhe: Os temperos são usados para condimentar os alimentos.
```

### 08. Resposta
```dart
// Classe base Ingrediente
class Ingrediente {
    
    String nome;
    String tipo;

    Ingrediente(this.nome, this.tipo);

    void detalhes() {
        print('Ingrediente: $nome');
        print('Tipo: $tipo');
    }

}

// Classe Fruta, que herda de Ingrediente
class Fruta extends Ingrediente {
    
    Fruta(String nome) : super(nome, 'Fruta');

    @override
    void detalhes() {
        print('Detalhe: As frutas geralmente não são cozidas nas receitas.');
    }

}

// Classe Legume, que herda de Ingrediente
class Legume extends Ingrediente {
    
    Legume(String nome) : super(nome, 'Legume');

    @override
    void detalhes() {
        print('Detalhe: Os legumes geralmente precisam ser cozidos nas receitas.');
    }

}

// Classe Tempero, que herda de Ingrediente
class Tempero extends Ingrediente {
    
    Tempero(String nome) : super(nome, 'Tempero');

    @override
    void detalhes() {
        print('Detalhe: Os temperos são usados para condimentar os alimentos.');
    }

}

void main() {
    
    // Criando instâncias de frutas, legumes e temperos
    var banana = Fruta('Banana');
    var cenoura = Legume('Cenoura');
    var sal = Tempero('Sal');

    // Exibindo os detalhes
    banana.detalhes();
    print('');
    cenoura.detalhes();
    print('');
    sal.detalhes();
    
}
```