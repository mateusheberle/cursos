# 02. Métodos: ações de uma conta

## Criando funções de transferência de valores

```dart
void main() {

    Conta contaMateus = Conta("Mateus", 1000);
    Conta contaRoberta = Conta("Roberta", 2000);

    List<Conta> contas = <Conta>[contaMateus, contaRoberta];

    for (Conta conta in contas) {
        print(conta.titular);
        print(conta.saldo);
    }

    contaRoberta.saldo = 5000;

    print(contaRoberta.saldo);

    receber(contaMateus, 500);

    print(contaMateus.titular);
    print(contaMateus.saldo);

    enviar(contaMateus, 200);

    print(contaMateus.titular);
    print(contaMateus.saldo);

}

void receber(Conta conta, double valor) {
    conta.saldo += valor;
}

void enviar(Conta conta, double valor) {
    conta.saldo -= valor;
}

class Conta {

    String titular;
    double saldo;

    Conta(this.titular, this.saldo);

}
```
```dart
Mateus
1000
Roberta
2000
5000
Mateus
1500
Mateus
1300
```

**Segunda tarefa**: Fazer transações (enviar e receber dinheiro)

> Ações = Funções.

Ações podem ser representadas por funções.

## Implementando métodos em uma classe Dart

```dart
class Conta {

    String titular;
    double saldo;

    Conta(this.titular, this.saldo);

    // Atrelar as funções à classe
    void receber(Conta conta, double valor) {
        conta.saldo += valor;
    }

    void enviar(Conta conta, double valor) {
        conta.saldo -= valor;
    }
}
```

Atrelar as funções à classe. Basta recortar e colar dentro da classe.

```dart
void main() {

    Conta contaMateus = Conta("Mateus", 1000);
    Conta contaRoberta = Conta("Roberta", 2000);

    List<Conta> contas = <Contas>[contaMateus, contaRoberta];

    for (Conta conta in contas) {
        print(conta.titular);
        print(conta.saldo);
    }

    contaRoberta.saldo = 5000;

    print(contaRoberta.saldo);

    contaMateus.receber(500);

    print(contaMateus.titular);
    print(contaMateus.saldo);

    contaMateus.enviar(200);

    print(contaMateus.titular);
    print(contaMateus.saldo);

}

class Conta {

    String titular;
    double saldo;

    Conta(this.titular, this.saldo);

    void receber(double valor) {
        saldo += valor;
    }

    void enviar(double valor) {
        saldo -= valor;
    }
}
```
Removemos: `Conta conta`. 

Todas as novas conta que ainda vão ser criadas, já vão possuir acesso a essas funções.

**Método**: outra forma de chamar funções dentro de classes.

## Protegendo dados sensíveis com propriedades privadas

Equipe de testes identificou que é possível alterar o valor do saldo sem passar pelas funções de `enviar()` e `receber()`.


```dart
void main() {

    Conta contaMateus = Conta("Mateus", 1000);
    Conta contaRoberta = Conta("Roberta", 2000);

    List<Conta> contas = <Conta>[contaMateus, contaRoberta];

    for (Conta conta in contas) {
        print(conta.titular);
        print(conta._saldo);
    }

    contaRoberta._saldo = 5000;

    print(contaRoberta._saldo);

    contaMateus.receber(500);

    print(contaMateus.titular);
    print(contaMateus._saldo);

    contaMateus.enviar(200);

    print(contaMateus.titular);
    print(contaMateus._saldo);

}

class Conta {

    String titular;
    double _saldo;

    Conta(this.titular, this._saldo);

    void receber(double valor) {
        _saldo += valor;
    }

    void enviar(double valor) {
        if (_saldo >= valor) {
            _saldo -= valor;
        }
    }
}
```

**Propriedades privadas**:

* Evitar acesso indesejado.
* Evitar que outras partes do código tenham acesso a elas.
* Como deixar uma variável privada: `_nomeDaVariavel`.
* É crucial que o **underline** esteja junto ao nome da variável, sem espaços.
* Variável privada tem acesso no **mesmo arquivo**. 
* Separando a classe `Conta` em outro arquivo, o acesso à variável `saldo` será restrito.

### Separando em 2 arquivos

**bin/anybank.dart**

```dart
import '../lib/conta.dart';

void main() {

    Conta contaMateus = Conta("Mateus", 1000);
    Conta contaRoberta = Conta("Roberta", 2000);

    List<Conta> contas = <Conta>[contaMateus, contaRoberta];

    for (Conta conta in contas) {
        print(conta.titular);
        print(conta._saldo);
    }

    contaRoberta._saldo = 5000;

    print(contaRoberta._saldo);

    contaMateus.receber(500);

    print(contaMateus.titular);
    print(contaMateus._saldo);

    contaMateus.enviar(200);

    print(contaMateus.titular);
    print(contaMateus._saldo);

}
```

**lib/conta.dart**

```dart
class Conta {

    String titular;
    double _saldo;

    Conta(this.titular, this._saldo);

    void receber(double valor) {
        _saldo += valor;
    }

    void enviar(double valor) {
        if (_saldo >= valor) {
            _saldo -= valor;
        }
    }
}
```
## Imprimindo extrato e acessando propriedades privadas

**bin/anybank.dart**

```dart
import '../lib/conta.dart';

void main() {

    Conta contaMateus = Conta("Mateus", 1000);
    Conta contaRoberta = Conta("Roberta", 2000);

    List<Conta> contas = <Conta>[contaMateus, contaRoberta];

    for (Conta conta in contas) {
        conta.imprimeSaldo();
    }

    contaRoberta.receber(3000);

    contaMateus.receber(500);

    contaMateus.enviar(200);

}
```

**lib/conta.dart**

```dart
class Conta {

    String titular;
    double _saldo;

    Conta(this.titular, this._saldo);

    void receber(double valor) {
        _saldo += valor;
        imprimeSaldo();
    }

    void enviar(double valor) {
        if (_saldo >= valor) {
            _saldo -= valor;
            imprimeSaldo();
        }
    }

    void imprimeSaldo() {
        print("O saldo atual de $titular, é R\$$_saldo");
    }

}
```
```dart
O saldo atual de Mateus, é R$1000
O saldo atual de Roberta, é R$2000
O saldo atual de Roberta, é R$5000
O saldo atual de Mateus, é R$1500
O saldo atual de Mateus, é R$1300
```

## Para saber mais: atributos privados

Em Dart, assim como em muitas linguagens de programação orientadas a objetos, podemos controlar o acesso aos atributos de uma classe utilizando **modificadores de acesso**.

### 01. O que são atributos privados?

* Atributos declarados como `private` são **visíveis e acessíveis apenas dentro da própria classe** em que foram definidos.
* Usar atributos privados promove o **encapsulamento**, um princípio fundamental da programação orientada a objetos. 
  * O encapsulamento **evita modificações indesejadas** de fora da própria classe, o que aumenta a segurança do código.

### 02. Por que usar atributos privados?

* **Proteção**: Ao tornar um atributo privado, você garante que ele não seja alterado acidentalmente ou de forma incorreta por outras classes ou métodos.
* **Organização**: A separação entre a lógica interna e externa de uma classe torna o código mais organizado e fácil de entender.
* **Reuso**: Atributos privados podem ser alterados internamente à classe sem afetar o código que utiliza essa classe.

```dart
class Pessoa {
  
    // Atributo privado para armazenar o nome
    String _nome;

    // Construtor para inicializar o atributo privado
    Pessoa(this._nome);

}
```

## Lista de exercícios

Você está desenvolvendo um Aplicativo de reservas de hotel em que clientes reservam quartos e gerenciam suas estadias. O sistema deve permitir que os clientes façam reservas, cancelem reservas, e consultem o status de suas reservas. Durante a implementação inicial, surgiram algumas necessidades de melhoria, como garantir a privacidade dos dados e otimizar a organização do código.

### 01. Criando uma classe de cliente

Escreva o código de uma classe que abstrai um cliente. As características (atributos) da classe são: nome do cliente e uma lista de quartos reservados. Apenas escreva a classe, sem mostrar nada no terminal com um print.

### 01. Resposta

```dart
class Cliente {
  
    String nome;
    List<String> reservas;

    Cliente(this.nome, this.reservas);

}
```

### 02. Realizando uma reserva de quarto

Implemente uma função dentro da classe `Cliente` que permita ao cliente fazer uma reserva de quarto. Essa função deve adicionar o quarto reservado à lista de reservas do cliente e, em seguida, exibir a lista atualizada de reservas. Certifique-se de que a função está corretamente encapsulada dentro da classe. Também, faça a instância da classe com um objeto, por exemplo, o cliente Joaquim.

### 02. Resposta

```dart
class Cliente {

    String nome;
    List<String> reservas;

    Cliente(this.nome, this.reservas);

    void fazerReserva(String quarto) {
        reservas.add(quarto);
        _mostrarReservas();
    }

    void _mostrarReservas() {
        print(reservas);
    }

}

void main() {

    Cliente cliente = Cliente('Joaquim', []);

    cliente.fazerReserva('101');
    cliente.fazerReserva('102');

}
```

### 03. Cancelando uma reserva

Implemente uma função dentro da classe `Cliente` que permita ao cliente cancelar uma reserva existente. A função deve remover o quarto da lista de reservas do cliente, desde que ele tenha uma reserva ativa para aquele quarto, e exibir a lista atualizada de reservas. Garanta que a função só permita o cancelamento se o cliente tiver realmente uma reserva para aquele quarto.

### 03. Resposta

```dart
class Cliente {

    String nome;
    List<String> reservas;

    Cliente(this.nome, this.reservas);

    void fazerReserva(String quarto) {
        reservas.add(quarto);
        _mostrarReservas();
    }

    void cancelarReserva(String quarto) {
        if (reservas.contains(quarto)) {
            reservas.remove(quarto);
            _mostrarReservas();
        }
    }

    void _mostrarReservas() {
        print(reservas);
    }

}

void main() {

    Cliente cliente = Cliente('Joaquim', []);
    
    cliente.fazerReserva('101');
    cliente.fazerReserva('102');
    cliente.fazerReserva('103');
    cliente.cancelarReserva('102');

}
```

### 04. Protegendo os dados das reservas

Altere o código da classe `Cliente` para que a lista de reservas seja uma propriedade privada, impedindo que ela seja alterada diretamente de fora da classe. Em vez disso, as operações de adicionar e cancelar reservas devem ser realizadas apenas por meio de métodos específicos dentro da classe. Verifique se a lista de reservas está protegida e testada corretamente.

### 04. Resposta

```dart
class Cliente {

    String nome;
    List<String> _reservas;

    Cliente(this.nome, this._reservas);

    void fazerReserva(String quarto) {
        _reservas.add(quarto);
        _mostrarReservas();
    }

    void cancelarReserva(String quarto) {
        if (_reservas.contains(quarto)) {
            _reservas.remove(quarto);
            _mostrarReservas();
        }
    }

    void _mostrarReservas() {
        print(_reservas);
    }

}

void main() {

    Cliente cliente = Cliente('Joaquim', []);

    cliente.fazerReserva('101');
    cliente.fazerReserva('102');
    cliente.fazerReserva('103');
    cliente.cancelarReserva('102');

}
```