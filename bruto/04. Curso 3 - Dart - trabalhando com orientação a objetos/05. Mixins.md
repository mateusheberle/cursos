# 05. Mixins

## Mexendo com mixins no Dart

**bin/anybank.dart**

```dart
import '../lib/conta.dart';

void main() {

    ContaCorrente contaChris = ContaCorrente("Chris", 4000);
    ContaPoupanca contaDenise = ContaPoupanca("Denise", 4000);
    ContaEmpresa contaMateus = ContaEmpresa("Mateus", 2000);
    ContaInvestimento contaMateus = ContaInvestimento("Roberta", 2000);

    contaChris.imprimirSaldo();
    contaChris.enviar(4300);
    
    contaDenise.imprimirSaldo();
    contaDenise.enviar(4300);
    contaDenise.calculaRendimento();
    contaDenise.imprimirSaldo();

    contaMateus.enviar(1000);
    contaRoberta.receber(1000);

}
```

**lib/conta.dart**

```dart
abstract class Conta {

    String titular;
    double _saldo;

    Conta(this.titular, this._saldo);

    void receber(double valor) {
        _saldo += valor;
        imprimeSaldo();
    }

    void enviar(double valor) {
        if (_saldo >= valor) {
            _saldo -= valor;
            imprimeSaldo();
        }
    }

    void imprimeSaldo() {
        print("O saldo atual de $titular, é R\$$_saldo");
    }

}

class ContaCorrente extends Conta {

    double empresimo = 300;

    ContaCorrente(super.titular, super._saldo);

    @override
    void enviar(double valor) {
        if (_saldo + emprestimo >= valor) {
            _saldo -= valor;
            imprimeSaldo();
        }
    }

}

class ContaPoupanca extends Conta {

    double rendimento = 0.05;

    ContaPoupanca(super.titular, super._saldo);

    void calculaRendimento() {
        _saldo += _saldo * rendimento;
    }

}

mixin Imposto {
    
    double taxa = 0.03;

    double valorTaxado(double valor) {
        return valor * taxa;
    }

}

class ContaEmpresa extends Conta with Imposto {
    
    ContaEmpresa(super.titular, super._saldo);

    @override
    void enviar(double valor) {
        if (_saldo >= valor + valorTaxado(valor)) {
            _saldo -= valor + valorTaxado(valor);
            imprimeSaldo();
        }
    }
    
    @override
    void receber(double valor) {
        _saldo += valor - valorTaxado(valor);
        imprimeSaldo();
    }

}

class ContaInvestimento extends Conta with Imposto {
    
    ContaInvestimento(super.titular, super._saldo);

    @override
    void enviar(double valor) {
        if (_saldo >= valor + valorTaxado(valor)) {
            _saldo -= valor + valorTaxado(valor);
            imprimeSaldo();
        }
    }

    @override
    void receber(double valor) {
        _saldo += valor - valorTaxado(valor);
        imprimeSaldo();
    }

}
```

Temos a tarefa de **criar 2 novas contas**:
* Conta **Investimento**.
* Conta **Empresa**.

Ambas terão uma funcionalidade de **cálculo de imposto**.

### Trabalhando com *Mixins* no Dart

A cada transação ou transferência que ocorrer em uma conta investimento ou em uma conta empresa, será aplicado um imposto. Por exemplo: se uma empresa transferir R$ 1.000,00, haverá um imposto de 3%. Assim, ao enviar R$ 1.000,00, será necessário pagar R$ 1.030,00, e ao receber, o valor será reduzido para R$ 970,00. Isso se aplica **tanto à conta investimento quanto à conta empresa**.

Um detalhe importante é que **ambas as contas terão a mesma funcionalidade**. Nesse caso, poderíamos pensar em usar herança, mas isso implicaria que todas as outras contas que herdam de Conta também precisariam ter esse cálculo de imposto.

Não é possível usar interface, pois isso demandaria uma implementação diferente para cada classe que a implementasse. Já no caso das contas investimento e empresa, **a implementação é a mesma**.

Além disso, foi especificado que **o cálculo de imposto pode ser aplicado em qualquer lugar no banco** onde seja necessário. Será um **valor fixo**, usado sempre que for necessário calcular o imposto sobre algum valor. Portanto, é uma funcionalidade consistente que **não pode ser herdada** por outros objetos, **nem ser criada como uma interface**.

A solução é utilizar uma funcionalidade do Dart chamada ***Mixins***.

### Utilizando a funcionalidade **`mixin`**

```dart
mixin Imposto {

    double taxa = 0.03;

    double valorTaxado(double valor) {
        return valor * taxa;
    }

}
```

* **Herança** utiliza a palavra reservada `extends`;
* **Interface** utiliza a palavra reservada `implements`.
* **Mixin** utiliza a palavra reservada `with`.

```dart
class ContaEmpresa extends Conta with Imposto {
    ...
}
```

### O que são *Mixins*

Mixins são conjuntos de **funcionalidades** que podem ser aplicadas a outras classes de **forma esporádica**. Pense no exemplo da capacidade de **voar**: ela pode ser aplicada tanto a aves quanto a aviões, embora não compartilhem uma classe comum, ressaltando a **flexibilidade** dos Mixins.

## Para saber mais: mais sobre mixins

### O que são mixins?

* **Mixins** são uma forma de **reutilizar código** em Dart **sem a necessidade de criar uma hierarquia** de herança complexa. 
* É como **adicionar uma característica sem precisar de uma implementação complicada** de superclasses. 
* Pense que você cria um **pequeno trecho de código** que pode ser reaproveitado para **executar alguma coisa** dentro do código.

### Por que usar mixins?

* Podemos compartilhar comportamentos entre classes sem criar uma hierarquia rígida.
* Mixins permitem combinar diferentes características em uma única classe.
* Funciona quase como **múltiplas heranças**.

```dart
mixin HabilidadeVoar {

    void voar() {
        print('Estou voando!');
    }

}

mixin HabilidadeNadar {

    void nadar() {
        print('Estou nadando!');
    }

}

class Pessoa {

    String nome;

    Pessoa(this.nome);

}

class SuperHeroi extends Pessoa with HabilidadeVoar, HabilidadeNadar {

    SuperHeroi(String nome) : super(nome);

}

void main() {

    SuperHeroi superHeroi = SuperHeroi('Super');
    superHeroi.voar();
    superHeroi.nadar();

}
```

* Nos **mixins `HabilidadeVoar` e `HabilidadeNadar`**, definimos as habilidades de voar e nadar (que são métodos);
* A **classe `Pessoa`** representa uma pessoa comum;
* A **classe `SuperHeroi`** herda de `Pessoa` e utiliza os mixins `HabilidadeVoar` e `HabilidadeNadar`. Ou seja, temos um super-herói que é uma pessoa que pode voar e nadar;
* Usamos a palavra-chave `with` para "misturar" ou "adicionar" os mixins à classe.

**Mixins**:  
* Pequenos trechos de códigos que **adicionam funcionalidades a uma classe**.
* Reutilizamos os mixins para adicionar métodos em uma classe. Porém o modo como um mixin faz isso é mais flexível e aberto se compararmos com herança de uma classe comum.
* Os mixins **complementam a herança tradicional**, permitindo que você crie classes mais completas sem lidar com heranças complexas.
* Mixins **não podem ter construtores**.
* A ordem dos mixins importa, pois pode haver conflitos de nomes.

## Princípios de POO

Primeiramente, recebemos tarefas com **problemas práticos** que precisavam ser resolvidos. A partir desses problemas, analisamos, **buscamos soluções** e as implementamos.

Com a prática você percebe que:
* **Problemas se repetem**.
* Pessoas encontram soluções.
* Essas soluções viram guias e padrões (POO).
* **Separar responsabilidades**.
* **Refletir sobre repetição de código**.
* POO tem mais a oferecer.

    Copiar e colar soluções não é uma boa forma de resolver problemas.

## Lista de exercícios

### 01. Criando um mixin para cálculo de taxa de bagagem

Crie um mixin chamado `TaxaBagagem` que tenha uma variável `taxa` com o valor de 10% e um método `calcularTaxa(double valor)` que retorne o valor da taxa sobre o total da passagem. Este mixin será utilizado para calcular a taxa adicional nas passagens que incluem bagagem.

### 01. Resposta
```dart
mixin TaxaBagagem {

    double taxa = 0.10;

    double calcularTaxa(double valor) {
        return valor * taxa;
    }

}
```

### 02. Criando uma passagem

Considere o seguinte código da classe abstrata `Passagem`:

```dart
abstract class Passagem {

    String cliente;
    double valorBase;

    Passagem(this.cliente, this.valorBase);

    double calcularPrecoFinal() {
        return valorBase;
    }

}
```

Implemente a classe `PassagemComBagagem` que herda de `Passagem` e utiliza o mixin `TaxaBagagem`. Sobrescreva a função de `calcularPrecoFinal`, de modo que o cálculo do preço final da passagem inclua a taxa de bagagem utilizando a função `calcularTaxa` do mixin.

### 02. Resposta
```dart
class PassagemComBagagem extends Passagem with TaxaBagagem {

    PassagemComBagagem(super.cliente, super.valorBase);

    @override
    double calcularPrecoFinal() {
        return valorBase + calcularTaxa(valorBase);
    }

}
```

### 03. Criando um mixin para cálculo de taxa de bagagem

Implemente a classe `PassagemSemBagagem` que herda de `Passagem`, mas não utiliza o mixin `TaxaBagagem`. A função `calcularPrecoFinal` para esta classe deve retornar apenas o valor da passagem sem qualquer taxa adicional.

### 03. Resposta
```dart
class PassagemSemBagagem extends Passagem {

    PassagemSemBagagem(super.cliente, super.valorBase);

}
```

### 04. Implementando controle de acesso com mixins

Você está desenvolvendo um sistema básico de gerenciamento para uma loja online. O sistema precisa gerenciar diferentes operações, como deletar usuários e adicionar produtos, mas somente administradores têm permissão para realizar essas operações críticas. Afinal, imagine se um usuário comum pudesse deletar e adicionar produtos em um site? Seria, sem dúvida, um caos. O usuário comum pode apenas comprar produtos, mas não modificá-los.

Para evitar a repetição de código ao verificar as permissões, você deve utilizar mixins no Dart para compartilhar essa funcionalidade de controle de acesso entre diferentes partes do sistema.

Comece assim: crie um mixin chamado `ControleAcesso` que tenha uma função `verificarPermissaoAdmin(String papel)` que retorne `true` se o papel for igual a `'admin'` e `false` caso contrário. Este mixin será utilizado para verificar se um usuário tem permissão para realizar operações críticas no sistema.

### 04. Resposta
```dart
mixin ControleAcesso {

    bool verificarPermissaoAdmin(String papel) {
        return papel == 'admin';
    }

}
```

### 05. Implementando controle de acesso com mixins

Implemente a classe `ServicoUsuario` que utilize o mixin `ControleAcesso`. Adicione um método `deletarUsuario` que somente permitirá a operação se o usuário tiver a permissão de administrador. Caso contrário, exiba a mensagem "Acesso negado". Escreva a classe no mesmo arquivo Dart em que você fez o mixin `ControleAcesso`.

### 05. Resposta
```dart
class ServicoUsuario with ControleAcesso {

    void deletarUsuario() {
        if (verificarPermissaoAdmin('admin')) {
            print('Usuário deletado');
        } else {
            print('Acesso negado');
        }
    }

}
```

### 06. Produzindo uma classe de adição de produtos

Escreva o código de uma classe chamada ServicoProduto, que utilize o mixin ControleAcesso. Adicione um método adicionarProduto, que somente permitirá a operação se o usuário tiver a permissão de administrador. Caso contrário, exiba a mensagem "Acesso negado". Implemente esta nova classe no mesmo arquivo que a classe `ServicoUsuario` e o mixin `ControleAcesso`.

### 06. Resposta
```dart
class ServicoProduto with ControleAcesso {

    void adicionarProduto() {
        if (verificarPermissaoAdmin('admin')) {
            print('Produto adicionado');
        } else {
            print('Acesso negado');
        }
    }

}
```

### 07. Melhorando a qualidade do código

Analise o código das classes `Serviço Usuário` e `ServicoProduto`. Identifique qualquer código repetitivo nas funções que verificam a permissão e refatore esse código, utilizando métodos auxiliares ou ajustando a lógica para evitar duplicação, garantindo que ambas as classes mantenham a funcionalidade adequada.

### 07. Resposta
```dart
mixin ControleAcesso {

    bool verificarPermissaoAdmin(String papel) {
        return papel == 'admin';
    }

    void executarOperacao(String papel, Function operacao) {
        if (verificarPermissaoAdmin(papel)) {
            operacao();
        } else {
            print('Acesso negado');
        }
    }

}

class ServicoUsuario with ControleAcesso {

    void deletarUsuario() {
        executarOperacao('admin', () => print('Usuário deletado'));
    }

}

class ServicoProduto with ControleAcesso {

    void adicionarProduto() {
        executarOperacao('admin', () => print('Produto adicionado'));
    }
    
}
```