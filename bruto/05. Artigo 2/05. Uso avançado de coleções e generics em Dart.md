# Uso avançado de coleções e generics em Dart

[Link Artigo Alura](https://www.alura.com.br/artigos/colecoes-e-generics-em-dart?utm_source=gnarus&utm_medium=timeline)


Coleções básicas, como: listas, conjuntos e mapas, nos ajudam a lidar com armazenamento temporário de dados em nossa aplicação.

**Generics**: Adicionam maior flexibilidade e reduz a duplicação de trechos de código, sem perder a segurança dos tipos.

## O que são coleções?

Tratar dados e organizá-los da melhor forma.
As principais coleções são:
* Listas
* Conjuntos
* Mapas

### Listas

* Coleções ordenadas, seguindo a ordem a qual inserimos os dados.
* Os elementos podem ser acessados através do índice.
* Ela pode receber qualquer tipo de dados, sendo: `String`, `int` ou até `object`.
* Para criar uma lista, precisamos primeiro definir o tipo de dados.
* Esse tipo fica dentro dos conchetes angulares (`<>`), informando que a lista será coposta por elementos daquele tipo.

```dart
void main() {
    List<String> listaDeConvidados = ['Scott', 'Fernanda', 'João', 'Nicolas', 'Bob'];
    print(listaDeConvidados[0]);
}
//A saída será Scott
```

### Map

* Mostra os dados de uma forma mais amigável e até mais fácil de visualizar.
* Usa o conceito de chave-valor, podemos facilmente visualizar o nome do elemento e o seu valor correspondente.
* Precisamos definir os tipos da chave e do valor ao criar um `Map`.
* Os elementos podem ser acessados através de sua chave única.

```dart
void main() {
    Map<String, double> produtosPrecos = {
        'Camiseta': 89.90,
        'Calça': 89.90,
        'Tênis': 149.90,
    };
    print(produtosPrecos);
}
//Saída: {Camiseta: 89.9, Calça: 89.9, Tênis: 149.9}
```

**Importante**: Não confundir o `Map` com a função `.map`. Podemos usar a função `.map` para iterar cada chave e valor de uma coleção `Map`.

### Conjuntos

* Conjuntos ou `Sets`.
* Não aceitam valores duplicados e não são ordenados.
* Valores duplicados são removidos automaticamente.

```dart
void main() {
    Set<int> numeros = {1, 2, 3, 4, 5};
    numeros.add(5);
    print(numeros); 
}
// a saída será: {1, 2, 3, 4, 5}
```

`{}`: `Map`.
`var conjunto = <String>{}` ou `Set conjunto = {}`: `Set`.

### Operações avançadas em coleções

Métodos para manipular e analisar os dados de uma coleção:
* `where`.
* `map`.
* `reduce`.
* `fold`.

### Where

Trabalha como um filtro que analisa a lista original e retorna uma nova lista baseada na condição aplicada. 

```dart
void main() {
    List<int> numeros = [-1, 2, -3, 4, 5];
    List<int> numerosPositivos = numeros.where((numbero) => numbero > 0).toList();
    print(numerosPositivos); 
}
//Saída: [2, 4, 5]
```

Usamos o `.toList()` no final para converter o resultado em uma lista.

### Map

Cria uma nova coleção transformando cada elemento da coleção original de acordo com uma determinada operação, mas sem alterar a lista original.

```dart
void main(){
   List<int> numeros = [1, 2, 3, 4, 5];
   List<int> doubled = numeros.map((numero) => numero * 3).toList();
   print(doubled); 
}
// Saída: [3, 6, 9, 12, 15]
```

### Reduce

Acumula valores em um único resultado, por isso é conhecido como função acumulativa.
Podemos utilizar em `List`, `Map` e `Set`.

```dart
void main() {
    Map<String, double> produtos = {
        'Shampoo': 12.99,
        'Creme': 14.49,
        'Gel': 9.99,
        'Condicionador': 15.89
    };
    double valorTotal = produtos.values.reduce((acumulador, preco) => acumulador + preco);
    print('Valor total dos produtos R\$ $valorTotal');
}
// Saída: Valor total dos produtos R$ 53.36
```

### Fold

Muito parecido com o `.reduce`, pois ambos permitem "acumular" os elementos de uma coleção em um único valor.
`fold()` é mais flexivel por permite um valor inicial para a acumulação.

```dart
void main(){
    List<int> numeros = [1, 2, 3, 4, 5];
    int soma = numeros.fold(0, (acumulador, numero) => acumulador + numero);
    print(soma); 
}
// Saída: 15
```

## O que são Generics em Dart?

É uma forma de criar classes, interfaces e funções que vão esperar um tipo sem precisar definir explicitamente esse tipo.

Método ou classe que pode trabalhar com qualquer tipo de dado.

## Por que utilizar generics?

* Reutilização de código
* Manutenção

Com tipos genéricos podemos criar classes e métodos que funcionam com qualquer tipo de dado sem precisar criar um para cada tipo, facilitando na manutenção dos mesmos.
Outro ponto é a segurança na compilação, podendo acusar erro no código antes do tempo de execução.

## Usando generics em coleções

`generics`: Não queremos ter que criar uma classe toda vez que precisar lidar com um novo tipo de dado.

*Exemplo*: 
* Organizar números de série com um `Repositorio<int>`, porém surgiu a necessidade de gerenciar nomes, ou seja, outro tipo de dados.
* Agora mudaria para `<String>`, então adaptamos o repositório `Repositorio<String>` usando **generics**.
* Agora precisamos de uma lista de pessoas, então temos `Repositorio<Pessoa>`.

```dart
class Repositorio<T> {

    List<T> itens = [];

    void adicionar(T item) {
        itens.add(item);
    }

    void remover(T item) {
        itens.remove(item);
    }

    @override
    String toString() {
        return itens.toString();
    }
}
```
```dart
class Pessoa {

    String nome;
    int idade;

    Pessoa(this.nome, this.idade);

    @override
    String toString() {
        return 'Pessoa(nome: $nome, idade: $idade)';
    }
}
```

Na `main()` podemos instanciar a classe `Repositorio` passando cada um dos tipos:

**Instância para `<int>`**:
```dart
void main(){
    var repositorioInteiros = Repositorio<int>();
    repositorioInteiros.adicionar(2);
    repositorioInteiros.adicionar(4);
    repositorioInteiros.adicionar(6);
    print('Repositório de Inteiros: $repositorioDeInteiros'); 
    // Saída: Repositório de Inteiros: [2, 4, 6]
}
```

**Instância para `<String>`**:
```dart
var repositorioStrings = Repositorio<String>();
    repositorioStrings.adicionar('Mobile');
    repositorioStrings.adicionar('Front-end');
    print('Repositório de Strings: $repositorioStrings'); 
    // Saída: Repositório de Strings: [Mobile, Front-end]
```

**Instância para `<Pessoa>`**:
```dart
var repositorioPessoas = Repositorio<Pessoa>();
  repositorioPessoas.adicionar(Pessoa('João', 70));
  repositorioPessoas.adicionar(Pessoa('Fernanda', 27));
  print('Repositório de Pessoas: $repositorioPessoas'); 
  /* Saída: Repositório de Pessoas: [
        Pessoa(nome: João, idade: 70), 
        Pessoa(nome: Fernanda, idade: 27)
    ] */
```

## Generics em construtores

**Construtores**:
* Criar instâncias de uma classe.
* Permitem inicializar objetos, definindo valores iniciais para suas propriedades e garantindo que estejam prontos para uso.

Conceito mais avançado: **generics**. Para tornar os construtores **reutilizáveis**.

*Exemplo*:
* Precisamos utilizar tipos de dados diferentes na mesma classe e construtor.
* Podemos definir uma classe com o nome `Personalizada`, que seja genérica, e passar o construtor genérico também, *assim conseguimos utilizá-la com tipos diferentes*.

```dart
class Personalizada<T> {

    T valor;

    Personalizada(this.valor);

    void mostrarValor() {
        print('O valor é: $valor');
    }
}
```

Usando o construtor da classe `Personalizada` com dois tipos diferentes:

**Utilizando `int`**:
```dart
var valorInt = Personalizada<int>(10);
valorInt.mostrarValor(); 
// Saída: O valor é: 10
```

**Utilizando `String`**:
```dart
var valorString = Personalizada<String>('Dart a linguagem do Flutter');
valorString.mostrarValor(); 
// Saída: Dart a linguagem do Flutter
```

Assim a classe se torna mais flexível e reutilizável, permitindo o uso de outros tipos.

## Generics em métodos estáticos

A diferença dos métodos estáticos dos métodos normais, é que eles não trabalham com dados específicos de uma instância da classe.

Podemos utilizar generics para permitir trabalhar com diferentes tipos. Essa combinação permite criar operações reutilizáveis e flexíveis.

Vamos utilizar uma classe genérica chamada **BaseRepository**, nela vamos implementar métodos estáticos genéricos que permitem salvar, buscar e deletar itens em um armazenamento simulado.

Esses métodos são úteis em situações onde precisamos manipular dados de forma centralizada, sem precisar instanciar a classe para cada operação.

**Criando a classe genérica**

amos criar a classe genérica **BaseRepository** e definir os métodos genéricos estáticos para essa classe, utilizaremos o **Map** para desempenhar a função de um armazenamento em memória, e o **_dataStore** guarda os dados que são salvos pelo repositório.

```dart
class BaseRepository<T> {
    static final Map<int, dynamic> _dataStore = {};
    static int _nextId = 1;
    // Método estático genérico para salvar um item
    static int save<T>(T item) {
        final id = _nextId++;
        _dataStore[id] = item;
        return id;
    }
    // Método estático genérico para obter um item por ID
    static T? getById<T>(int id) {
        return _dataStore[id] as T?;
    }
    // Método estático genérico para deletar um item pelo ID
    static bool delete(int id) {
        return _dataStore.remove(id) != null;
    }
}
```

**Exemplo utilizando a classe e os métodos**

```dart
void main() {
    // Salvando novos itens
    final userId = BaseRepository.save('User: Alice');
    final productId = BaseRepository.save('Product: Widget');
    // Obtendo itens por ID
    print(BaseRepository.getById<String>(userId)); 
    // Saída: User: Alice
    
    print(BaseRepository.getById<String>(productId)); 
    // Saída: Product: Widget
    // Deletando um item
    BaseRepository.delete(userId);
    print(BaseRepository.getById<String>(userId)); 
    // Saída: null
}
```

## Mixins e extensões em coleções genéricas

**Mixins**: É uma maneira de adicionar funcionalidades e propriedades a uma classe sem usar herança.

Útil quando precisamos passar uma propriedade ou método para uma subclasse que precisa desse método sem depender da herança, já que na herança todas subclasses têm o acesso a todas propriedades da classe pai. Pensando com o generics, isso ajuda a criarmos funcionalidades reutilizáveis.

**Utilizando Mixins**

- Herança: palavra reservada `extends`
- Mixin: palavra reservada `with`

Conseguimos herdar a superclasse e ainda herdar o Mixin na mesma classe.

**Exemplo**: Imagine uma empresa onde tem os funcionários, e cada funcionário vai ter as suas habilidades, por exemplo, um funcionário pode ser um **Lider**, outro pode ser um **Desenvolvedor(a)**, outro pode ter as duas habilidades de **Lider** e **Desenvolvedor(a)**. Podemos criar uma classe com uma função que venha herdar a superclasse e incorporar o mixin.

1. Primeiro vamos definir os *Mixins* de **Lider** e **Desenvolvedor**.

```dart
mixin Lider {
    void liderarEquipe() {
        print('Liderando a equipe...');
    }
}
mixin Desenvolvedor {
    void programar() {
        print('Desenvolvendo uma aplicação...');
    }
}
```

2. Agora vamos criar a classe `Funcionario`.

```dart
class Funcionario {
    final String nome;
    Funcionario(this.nome);
    void trabalhar() {
        print('$nome está trabalhando...');
    }
}
```

3. O próximo passo é criar a classe com a função do funcionário, que vai herdar da classe `Funcionario` e incorporar o *Mixin*.

```dart
class Gerente extends Funcionario with Lider {
    Gerente(super.nome);
}
class EspecialistaDesenvolvedor extends Funcionario with Desenvolvedor {
    EspecialistaDesenvolvedor(super.nome);
}
class LiderDesenvolvedor extends Funcionario with Lider, Desenvolvedor {
    LiderDesenvolvedor(super.nome);
}
```

4. Por último, podemos criar diferentes tipos de funcionários e ver como eles utilizam suas habilidades específicas.

```dart
void main() {
    var gerente = Gerente('Alice');
    gerente.trabalhar(); 
    // Saída: Alice está trabalhando...
    gerente.liderarEquipe(); 
    // Saída: Liderando a equipe...
    var especialista = EspecialistaDesenvolvedor('Bob');
    especialista.trabalhar(); 
    // Saída: Bob está trabalhando...
    especialista.programar(); 
    // Saída: Desenvolvendo uma aplicação...
    var liderApresentador = LiderDesenvolvedor('Carol');
    liderApresentador.trabalhar(); 
    // Saída: Carol está trabalhando...
    liderApresentador.liderarEquipe(); 
    // Saída: Liderando a equipe...
    liderApresentador.programar(); 
    // Saída: Desenvolvendo uma aplicação...
}
```

## Mixins em coleções genéricas

Podemos combinar Mixins com coleções genéricas para criar um código ainda mais versátil e flexível.

Podemos testar isso com um exemplo real, utilizando um cenário de trabalho, como um gerenciamento de estoque de produtos em uma loja.

Nesse caso, o mixin adicionar funcionalidades para calcular o valor total do estoque e filtrar os produtos com base nas condições.

1. Vamos criar um mixin chamado `GerenciamentoEstoque<T>` que adiciona métodos para calcular o valor total do estoque e filtrar produtos com base em um critério específico.

```dart
mixin GerenciamentoEstoque<T> {
    // Método para calcular o valor total do estoque
    double calcularValorTotal(Iterable<T> produtos, double Function(T) getPreco) {
        return produtos.fold(0, (total, produto) => total + getPreco(produto));
    }
    // Método para filtrar produtos com base em um critério
    Iterable<T> filtrarProdutos(Iterable<T> produtos, bool Function(T) criterio) {
        return produtos.where(criterio);
    }
}
```

2. Agora, vamos criar uma classe genérica com o nome `Estoque<T>` que incorpora e utiliza o mixin `GerenciamentoEstoque` para adicionar as funcionalidades definidas.

```dart
class Estoque<T> with GerenciamentoEstoque<T> {
    final Iterable<T> produtos;
    Estoque(this.produtos);
    // Método para exibir o valor total do estoque
    void exibirValorTotal(double Function(T) getPreco) {
        print('Valor total do estoque: R\$${calcularValorTotal(produtos, getPreco)}');
    }
    // Método para exibir os produtos filtrados
    void exibirProdutosFiltrados(bool Function(T) criterio) {
        var produtosFiltrados = filtrarProdutos(produtos, criterio);
        for (var produto in produtosFiltrados) {
            print(produto);
        }
    }
}
```

3. Por último, podemos criar uma classe `Produto` para representar os itens no estoque e usar a classe `Estoque<T>` para gerenciar esses produtos.

```dart
class Produto {
    final String nome;
    final double preco;
    final int quantidade;
    Produto(this.nome, this.preco, this.quantidade);

    @override
    String toString() {
        return '$nome - R\$$preco - Quantidade: $quantidade';
    }
}
void main() {
    // Exemplo com uma lista de produtos
    var produtos = [
        Produto('Notebook', 3500.0, 5),
        Produto('Smartphone', 2500.0, 10),
        Produto('Mouse', 150.0, 50),
        Produto('Teclado', 200.0, 20),
    ];
    var estoque = Estoque<Produto>(produtos);
    // Exibindo o valor total do estoque
    estoque.exibirValorTotal((produto) => produto.preco * produto.quantidade);
    // Saída: Valor total do estoque: R$37500.0
    // Filtrando e exibindo produtos com preço acima de R$1000
    print('Produtos com preço acima de R\$1000:');
    estoque.exibirProdutosFiltrados((produto) => produto.preco > 1000.0);
    // Saída:
    // Notebook - R$3500.0 - Quantidade: 5
    // Smartphone - R$2500.0 - Quantidade: 10
}
```

Combinando Mixins e coleções genéricas, conseguimos um código robusto e adaptável.

## Extensões em coleções genéricas

As extensões em Dart são como aquelas sugestões de autocompletar que a IDE oferece, mas de forma personalizada, porém criada por nós.

Sabe quando você está codando e a IDE sugere métodos nativos que facilitam seu trabalho? Com as extensões você pode criar essas mesmas sugestões, mas do seu jeito. Elas permitem que você adicione novos métodos ou funcionalidades a tipos já existentes sem precisar modificar o código original dessas classes.

**Criando a extensão**

Um exemplo prático é criar uma extensão para encontrar o valor máximo e mínimo em uma coleção. Isso é útil quando precisamos garantir que os números inseridos estejam dentro de um intervalo aceitável.

Por exemplo, em um formulário, podemos usar essa extensão para identificar a pessoa de maior e menor idade entre os dados coletados.

Definimos a extensão passando a palavra `extension` seguida do nome, nesse exemplo utilizaremos o nome `MinMax`, em seguida passamos à propriedade on seguida do tipo `Iterable` a qual a extensão vai ser aplicada.

```dart
extension MinMax<E extends num> on Iterable<E> {
    E? encontrarMaximo() {
        return isEmpty ? null : reduce((a, b) => a > b ? a : b);
    }
    E? encontrarMinimo() {
        return isEmpty ? null : reduce((a, b) => a < b ? a : b);
    }
}
//Utilizando a extensão
void main() {
    var lista = [13, 15, 17, 22, 28, 21];
    print(lista.encontrarMaximo()); 
    // Saída: 28
    print(lista.encontrarMinimo()); 
    // Saída: 13
}
```

## Covariância e contravariância em generics

Vamos ver como conceitos como covariância e contravariância podem aprimorar ainda mais a forma como trabalhamos com tipos genéricos em Dart.

Covariância e contravariância em generics é uma forma de definir como os tipos de dados podem ser substituídos, especialmente em coleções genéricas.

Vamos imaginar uma caixa de frutas onde podemos colocar diferentes tipos de frutas. Essa caixa pode ser específica para uma única fruta ou pode ser uma caixa genérica de frutas, onde podemos colocar qualquer tipo de fruta.

## Covariância

É como dizer: eu tenho uma caixa de maçãs, mas posso usar como uma caixa genérica para qualquer fruta. Isso é muito útil se alguém pedir uma caixa de frutas, podemos entregar a caixa de maçãs sem problemas.

Se tratando do Dart, as listas já são **covariantes**, isso significa que podemos tratar uma `List<string>`(caixa de maçãs) como se fosse uma `List<Object>`(caixa de frutas).

```dart
void main() {
    // Uma lista genérica de frutas e objetos
    List<Object> frutas = ['Maçã', 123, true]; 
    List<String> macas = ['Fuji', 'Gala'];
    // Tratando uma caixa de maçãs como se fosse uma caixa de frutas
    frutas = macas; 
    print('Frutas $frutas');
}
//Saída: Frutas [Fuji, Gala]
```

## Contravariância

Seria o oposto de variância. É como se tivesse uma caixa de frutas genérica e quisesse usá-la apenas para maçãs. Faz mais sentido e é mais utilizada em funções, é como se tivesse uma função que aceita diferentes tipos de caixas de frutas.

```dart
void adicionarFrutasNaCaixa(List<Object> caixaDeFrutas) {
    // Adiciona itens genéricos na caixa de frutas
}
void main() {
    List<String> macas = ['Fuji', 'Gala'];
    adicionarFrutasNaCaixa(macas); 
}
```

## Algoritmos genéricos em classes e coleções

Esses algoritmos podem operar sobre diferentes tipos de coleções de maneira flexível e reutilizável, através dos tipos genéricos.

Vamos ver agora como utilizar generics para resolver problemas comuns, utilizando algoritmos genéricos que trabalham com coleções.

Já vamos pensar em um jogo, onde precisamos encontrar o vencedor através de sua pontuação, no caso o maior pontuador vence. Podemos criar um algoritmo genérico para encontrar o maior valor em uma lista.

```dart
T maiorValor<T extends Comparable>(List<T> itens) {
    T itemMaximo = itens[0];
    for (var item in itens) {
        if (item.compareTo(itemMaximo) > 0) {
            itemMaximo = item;
        }
    }
    return itemMaximo;
}
```
**Utilizando o tipo `Int`**

```dart
void main() {
    var valores = [3, 5, 1, 10, 4];
    var numeroMaximo = maiorValor(valores);
    print('Maior número: $numeroMaximo');
}
//Saída: Maior número é 10
```

**Utilizando o tipo `String`**

Utilizaremos esse mesmo código para uma lista de `Strings`. Temos agora um estoque de produtos de uma loja de roupas, tênis e acessórios, onde queremos descobrir qual é o último produto (em ordem alfabética) da nossa lista de produtos.

```dart
void main() {
    var produtos = ['Sapato', 'Blusa', 'Calça', "Pulseira"];
    var ultimoProduto = maiorValor(produtos);
    print('Última palavra em ordem alfabética é $ultimoProduto');
}
//Saída: Última palavra em ordem alfabética é Sapato
```

Podemos pensar em um outro caso utilizando um algoritmo genérico para filtrar elementos de uma lista. Isso é útil quando precisamos categorizar elementos em uma lista, sem utilizar o método adicional(Where).

Por exemplo, considere uma brincadeira de futebol, onde precisamos escolher os(as) jogadores(as) para os times. Podemos criar um algoritmo genérico para determinar os(as) jogadores(as) de idade pares para um time, filtrando os números pares de uma lista:

```dart
List<T> filtrar<T>(List<T> itens, bool Function(T) teste) {
    List<T> listaFiltrada = [];
    for (var item in itens) {
        if (teste(item)) {
            listaFiltrada.add(item);
        }
    }
    return listaFiltrada;
}
```

**Utilizando o tipo Int**

```dart
void main() {
    var idades = [13, 18, 20, 22, 14, 23, 16, 19, 17, 25];
    var numerosPares = filtrar(idades, (n) => n % 2 == 0);
    print('Números pares $numerosPares');
}
// Saída: Números pares [18, 20, 22, 14, 16]
```

**Utilizando o tipo String**

Aqui podemos usar um jogo de palavras como exemplo. Vamos supor que precisamos utilizar em nosso jogo somente palavras que tenham 5 ou menos letras. 

```dart
void main(){
    var palavras = ['Dart', 'Flutter', 'Mobile', 'App'];
    var palavrasCurtas = filtrar(palavras, (palavra) => palavra.length <= 5);
    print('Palavras curtas $palavrasCurtas');
}
// Saída: Palavras curtas [Dart, App]
```

Depois de aprender um monte de coisas, como generics e coleções genéricas, precisamos começar a tratar esses dados e garantir que tudo funcione corretamente, não é mesmo?

Agora vamos explorar como lidar com erros e validar informações para garantir que tudo funcione corretamente.

## Lidando com erros e validação em coleções genéricas

Sempre que estamos codando e trabalhando com diferentes tipos de dados, problemas e erros podem aparecer durante o desenvolvimento de nossa aplicação. Trabalhando com generics não é diferente, alguém pode definir uma tipagem e tentar passar outra na hora de utilizar.

Para que isso não aconteça, precisamos então, tratar esses erros para garantir que o nosso código funcione corretamente.

## Tratamento de erro em tipos

Como estamos utilizando generics, o tipo de dados é definido em tempo de compilação, porém se alguém tentar adicionar um tipo de dado incorreto em uma coleção ou classe genérica, o compilador pode detectar isso como um erro.

Temos uma classe genérica chamada `Customizada`. Na hora de utilizá-la, podemos "tipá-la" para receber somente números inteiros: `var customizadaInt = Customizada<int>();`. Imagina alguém tentar adicionar uma `String`. Veja abaixo o que acontece:

```dart
class Customizada<T> {
    T? item;
    void add(T novoItem) {
        item = novoItem;
    }
    T? get() {
        return item;
    }
}
```
**Correto**

```dart
void main() {
    var customizadaInt = Customizada<int>();
    customizadaInt.add(5); // Correto
    print(customizadaInt.item);
}
// Saída: 5
```

**Errado**

```dart
void main() {
    var customizadaInt = Customizada<int>();
    customizadaInt.add("Hello"); 
    print(customizadaInt.item); 
}
```

Dessa forma passando uma `String` onde espera um `Int`, um erro será exibido

```sh
Erro: The argument type 'String' can't be assigned to the parameter type 'int'.
```

## Validação de dados

Mesmo trabalhando com generics, pode ser necessário validar os dados antes de adicioná-los a uma coleção ou utilizá-los. Para fazer essa validação, podemos utilizar nossos amigos: `if` e `else` para testar uma condição.

Vamos pensar em um sistema de conta bancária onde precisamos depositar um valor positivo na conta, onde não podemos depositar um valor que seja negativo ou zero. Podemos utilizar o `if` e `else` para aceitar somente valores maiores que `0`. Vamos ver no código:

**Definindo a classe**

```dart
class NumeroPositivo<T extends num> {
    List<T> itens = [];
    void add(T item) {
        if (item > 0) {
            itens.add(item);
        } else {
            print("O valor precisa ser maior que zero. Valor: $item");
        }
    }
    List<T> get() {
        return itens;
    }
}
```

**Utilizando**

Se o número inserido for maior que `0`, está correto e o número será adicionado a lista, caso contrário se for um número igual ou menor que zero, exibe a mensagem de erro: `O valor precisa ser maior que zero. Valor -5`

```dart
void main() {
    var positivos = NumeroPositivo<int>();
    positivos.add(10); // Correto
    positivos.add(-5); // Erro: O valor precisa ser maior que zero. Valor -5
    print(positivos.get()); // Saída: [10]
}
```

Com essa validação garantimos que quem utilizar nossa aplicação, poderá inserir somente números positivos e do tipo inteiro em nossa coleção. Com isso, temos um código que funciona corretamente de forma segura.

## Conclusão

Neste artigo, vimos como funcionam as coleções e seus métodos principais. Depois, falamos da importância dos generics e como utilizá-los para deixar o nosso código mais flexível e reutilizável, tanto para coleções quanto para classes.

Também vimos sobre mixins e extensões para deixar o código ainda mais dinâmico. E, no final, passamos pela validação e tratamento de erros para garantir que tudo funcione direitinho.
