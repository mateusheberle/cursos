## Isolando em um serviço

**Ao revisitar a `main`**, notamos outro problema: **temos funções espalhadas por ela, o que não é o ideal**. **O ideal seria modularizar** isso, **trazendo para uma classe responsável apenas pela comunicação com a API**.

Essas classes, que têm o **papel de se comunicar com a API**, são chamadas de diversas formas, dependendo do padrão de projeto utilizado ou stack da empresa. Podem ser **chamadas de `client`, `API client`, `service` (serviço), entre outros**.

**O importante é modularizar**, ou seja, **trazer esse código para outra classe para que outras classes possam utilizá-la**. Neste caso, **chamaremos de `service`**, pois é um termo bem comum.

### Isolando o serviço

Para isso, no VSCode, pressionamos "Ctrl + B" para abrir o explorador na lateral esquerda. Na pasta "lib", vamos **criar uma nova pasta chamada "services"**, que se comunica com os serviços que operam na web.

Dentro de "Services", **criamos um novo arquivo chamado `account_service`**. Nele, **vamos criar uma classe `AccountService`**.

Nosso trabalho agora é **transferir tudo que é relativo à comunicação com a API para essa classe**, retirando da `main`. Podemos fazer isso passo a passo.

Primeiramente, **removemos o controlador de `streams`**. Esse controlador serve para comunicação, mas quem está fora da classe de comunicação não precisa ter acesso a ele, apenas à `stream`. Faz sentido, assim como um streamer não permite que mexamos em sua transmissão, mas podemos assisti-la.

Após **recortar o `StreamController` de `main.dart`**, vamos **colá-lo dentro da classe `AccountService`**. Não se preocupe com os erros, pois estamos movendo o código.

Precisamos **importar a biblioteca de assincronismo**, o que pode ser feito pressionando "Ctrl + ponto" para abrir o assistente de refatoração e importar a biblioteca `dart:async`.

Para dar acesso à `stream`, vamos criar um `getter`. Após o controlador, criamos uma Stream com subtipo `<String>`, que é um `get`, chamado `streamInfos`. Poderia ser apenas `stream`, mas como estamos enviando informações, é bom deixar claro. Agora, basta fazer uma arrow para passar o `streamController.stream`.

É importante lembrar que quem está fora do `Account` não deveria ter acesso ao controlador, **então tornamos o atributo privado colocando um underline na frente** de streamController.

```dart
// account_service.dart:
import 'dart:async';

class AccountService {
  StreamController<String> _streamController = StreamController<String>();
  Stream<String> get streamInfos => _streamController.stream;
}
```

Em seguida, podemos **deletar todas as chamadas de funções que estão dentro da `main`**, pois iremos usar os métodos do serviço. Então, vamos apagar as chamadas de `StreamSubscription`, `requestData`, `requestDataAsync` e `sendDataAsync`.

Agora, vamos analisar a função `requestData()`, a qual criamos para aprender a usar o `then`. No entanto, **ao criar um serviço, idealmente usamos `async-await`**. Isso permite que o **serviço controle cada linha de uma operação assíncrona sem agendamentos**. Algo externo ao serviço pode fazer um agendamento, mas o serviço deve fazer cada operação para uma resposta consistente.

Portanto, a **função `requestData()`**, que foi didaticamente interessante, não é mais necessária. Podemos **apagá-la** e utilizar a função assíncrona `requestDataAsync()` em seu lugar.

Vamos **recortar a `requestDataAsync()` e colá-la dentro do `AccountService`**, após à `Stream`.

**Falta importar os pacotes necessários**. A `main` não precisará mais de suas importações, pois ficará vazia, então podemos recortar da linha 1 à 5 e colar em AccountService.

Um erro ocorre no `requestDataAsync()`, porque precisamos **tornar o `streamController` privado, adicionando o underline**. Além disso, **tornamos o `streamController` como final**. Salvamos e indentamos o código.

```dart
import 'dart:async';

import 'package:dart_assincronismo/api_key.dart';
import 'package:http/http.dart';
import 'dart:convert';

class AccountService {
  final StreamController<String> _streamController = StreamController<String>();
  Stream<String> get streamInfos => _streamController.stream;

  Future<List<dynamic>> requestDataAsync() async {
    String url = "https://gist.githubusercontent.com/ricarthlima/a0eb198cb7a70696c4031e7e577de0cd/raw/356ce2c39dfd58d3d2e948d1ad87ea828544f1db/accounts.json";
    Response response = await get(Uri.parse(url));
    _streamController.add("${DateTime.now()} | Requisição de leitura.");
    return json.decode(response.body);
  }
}
```

Só falta trazer o método de enviar a informação. **Selecionamos e recortamos o `sendDataAsync()` e o colamos no final da `AccountService`**.

Podemos salvar a `main()`, que ficará vazia, por enquanto. Depois, vamos preenchê-la.

```dart
// main.dart:

void main() {}
```

Voltando ao `account_service.dart`, dentro do `sendDataAsync()`, devemos adicionar o underline na frente do `streamController` nas linhas 42 e 45, dentro do if e else.

Após fazer a migração do código, devemos fazer ainda mais algumas alterações. **A url será a mesma para todos os métodos do serviço**. É bem comum os métodos de um serviço precisarem de uma mesma URL, host ou até endpoint.

Por isso, **não precisamos que a url esteja dentro de cada método**, **pois isso é redundante e pode causar erros de manutenção**.

Recortamos a url de `sendDataAsync()`, retirando-a de dentro do método, e colamos como atributo dentro da classe. Também apagamos a url do método `requestDataAsync()`.

A URL do método de `requestDataAsync()` não é exatamente igual a URL usada no `sendDataAsync()`. Mas, estamos isolando a URL que segue o padrão explicitado na documentação, ou seja, `api.github.com/gists/id`.

A URL que estávamos usando para fazer a comunicação era, na verdade, a URL navegador - o que não é ideal para a API. Portanto, podemos apagar a url do `requestDataAsync()`. Assim, as entradas para a url em ambos métodos se tornam referentes ao atributo da classe - e não mais a variável dentro dos métodos.

Por fim, vamos **renomear os métodos para ficar mais padronizado. Assim, `requestDataAsync()` se torna `getAll()` e `sendDataAsync()` se torna `addAccount()`**. Lembre-se de corrigir o uso desses métodos, passando os novos nomes.

Por padrão, chamamos de **`getAll()` o método que pega todos os elementos no servidor** e chamamos de **`AddAccount` o método que adiciona uma conta**.

```dart
// account_service.dart:

import 'dart:async';

import 'package:dart_assincronismo/api_key.dart';
import 'package:http/http.dart';
import 'dart:convert';

class AccountService {
  final StreamController<String> _streamController = StreamController<String>();
  Stream<String> get streamInfos => _streamController.stream;

  String url = "https://api.github.com/gists/413c0aefe6c6abc464581c29029c8ace";

  Future<List<dynamic>> getAll() async {
    Response response = await get(Uri.parse(url));
    _streamController.add("${DateTime.now()} | Requisição de leitura.");
    return json.decode(response.body);
  }

  addAccount(Map<String, dynamic> mapAccount) async {
    List<dynamic> listAccounts = await getAll();
    listAccounts.add(mapAccount);
    String content = json.encode(listAccounts);

    Response response = await post(
      Uri.parse(url),
      headers: {"Authorization": "Bearer $githubApiKey"},
      body: json.encode({
        "description": "account.json",
        "public": true,
        "files": {
          "accounts.json": {
            "content": content,
          }
        }
      }),
    );

    if (response.statusCode.toString()[0] == "2") {
      _streamController.add(
          "${DateTime.now()} | Requisição adição bem sucedida (${mapAccount["name"]}).");
    } else {
      _streamController.add(
          "${DateTime.now()} | Requisição falhou (${mapAccount["name"]}).");
    }
  }
}
```

Fizemos uma **grande migração de código da `main` para o `service`**, mas ainda não estamos usando o modelo que criamos.