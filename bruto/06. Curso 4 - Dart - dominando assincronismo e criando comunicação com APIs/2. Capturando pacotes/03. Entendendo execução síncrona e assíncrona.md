## Entendendo execução síncrona e assíncrona

Fizemos nossa primeira requisição, aprendemos a esperar ela acontecer, coletar o corpo, tratar e obter uma informação. No entanto, é importante lembrar que o **GET é uma operação assíncrona**.

### Entendendo operações assíncronas

Para ilustrar, vamos ao arquivo `main.dart`, após o bloco `then()`, onde adicionaremos um `print()` direto da mensagem "Última coisa a acontecer na função".

```dart
requestData() {
    String url = "https://gist.githubusercontent.com/ricarthlima/a0eb198cb7a70696c4031e7e577de0cd/raw/356ce2c39dfd58d3d2e948d1ad87ea828544f1db/accounts.json";
    Future<Response> futureResponse = get(Uri.parse(url));
    print(futureResponse);
    futureResponse.then(
        (Response response) {
            print(response);
            print(response.body);
            List<dynamic> listAccounts = decode(response.body);
            Map<String, dynamic> mapCarla = listAccounts.firstWhere(
                (element) => element["name"] == "Carla",
            );
            print(mapCarla["balance"]);
        },
    );
    
    print("Última coisa a acontecer na função.");
}
```

Pela ordem que conhecemos, o editor rodará a linha `String url` para definir a URL, depois a linha seguinte para guardar o `future`, a próxima para imprimir, e as linhas subsequentes para aguardar, imprimir o `body`, coletar as informações de Carla, e assim por diante. Por fim, ele imprimirá a mensagem que adicionamos.

Ao salvar o arquivo e executar no terminal o `dart run bin/main.dart`, observamos que **a mensagem adicionada não aparece por último, mas sim, em segundo lugar**.

```sh
dart run bin/main.dart
```
Retorno:

```
Instance of 'Future<Response>'
Última coisa a acontecer na função.
Instance of 'Response'
[{
"id": "ID001",
"name": "Ricarth",
"lastName": "Lima",
"balance": 113.0
}],

(retorno omitido)
```

**Primeiro, ele imprimiu o `future` e o `response`**, e **logo em seguida, imprimiu a mensagem**. Só depois, imprimiu as outras partes.

Isso pode parecer confuso, mas faz todo sentido. **Quando pedimos para que `then()` faça algo ao terminar**, há o **agendamento de um comportamento** na linha que o inicia. Tudo que existe entre as chaves de `then( (Response response) )` **está agendado**.

**Quando acabar a execução anterior, ele executa o que está agendado**. Mas isso não significa que o Dart vai parar. **Ele agenda e segue em frente**. Se houvesse mais mil linhas abaixo, ele continuaria executando.

Na prática, ele rodou a linha antes do `then()`, o agendou e saltou para a linha após o seu término. Esse **movimento é instantâneo**, **ocorrendo logo após a linha antes do `then()`**. Já o **agendamento demora**, pois é uma **operação assíncrona**. *Ele só exibe o que acontece dentro do bloco agendado após mostrar tudo o que aconteceu nas outras linhas*.

Estamos lidando com um novo conceito. Podemos pensar que **o algoritmo é uma receita de bolo**, **seguindo passo a passo**. No entanto, agora estamos tratando com eventos que demoram. Não necessariamente porque o `print()` está em determinada linha que ele ocorrerá após a linha anterior. Esse é um novo pensamento que devemos adotar.

### Exemplificando a ordem do código

Para fixar isso, vamos usar um **exemplo de fluxo de execução**. Quando aprendemos a programar, aprendemos que o algoritmo é uma receita que segue passos, portanto, utilizaremos com o mesmo exemplo.

Faremos uma **salada de ovo**. Para isso, seguiremos os passos abaixo:

1. Lavar os legumes;
2. Cozinhar o ovo;
3. Picar os legumes;
4. Descascar o ovo;
5. Montar a salada.

São passos bem definidos que poderiam ser as linhas 1, 2, 3, 4, 5 no código.

No entanto, **cozinhar o ovo é um evento assíncrono, pois é demorado**. Cozinhar o ovo pode demorar por volta de 12 minutos.

Já lavar e picar legumes, descascar o ovo e montar a salada são ações rápidas. Temos essa mesma lógica no código: definir uma variável ou construir uma declaração de future é praticamente instantâneo. Já uma **operação assíncrona demora para ser executada**.

Nesse caso, temos **duas ordens de execução** que podem ser seguidas:

1. **Esperar o ovo terminar de cozinhar** para então picar os legumes, descascar e montar a salada;
2. **Agendar o descascamento do ovo e a montagem da salada para quando o ovo terminar de cozinhar**, enquanto picamos os legumes.

No Dart, esse agendamento é feito com o `then()`, que significa "quando". **Quando usamos o `then()`, estamos agendando uma ação**. Se houver mais passos que não dependem desse agendamento, como picar os legumes, continuamos executando.

No código, picar os legumes é o `print()` com a mensagem "Última coisa a acontecer na função". O descascamento e a montagem da salada ocorrem dentro do `then()`, agendados para o futuro.

### Próximos passos

Em meio a esse fluxo, é possível seguir a primeira forma de execução, cozinhando o ovo, picando os legumes e só então descascando e montando, mesmo que o ovo demore. **Não precisamos sempre lidar com agendamentos**.