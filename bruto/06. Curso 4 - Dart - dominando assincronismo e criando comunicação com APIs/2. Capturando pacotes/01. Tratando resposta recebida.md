## Tratando resposta recebida

Conseguimos realizar a requisição e obter a resposta. 

No entanto, pode surgir a dúvida: *Como extrair uma informação específica desse grande volume de dados?*

Por exemplo, queremos **saber o saldo na conta de Carla**. Não queremos visualizar isso apenas no terminal; precisamos dessa informação no código. *Como podemos extrair isso?*

A string não está formatada de forma aleatória, mas sim como um **JSON (JavaScript Object Notation)**. Apesar do nome, não é algo diretamente relacionado ao JavaScript, mas sim uma **forma de formatação que facilita a extração de informações**.

Se observarmos o terminal, veremos que **a string começa e termina com colchetes**, e **cada elemento começa e termina com chaves**. Esses elementos são separados por uma chave, que é sempre uma string (como id, name, lastName, balance), enquanto os valores podem ser strings ou outros tipos, como double.

Isso nos lembra que **tudo fora dos colchetes é uma lista**, com índices enumerados sequencialmente, e **dentro desses elementos temos Maps**, cada um com uma **chave (string) e um valor dinâmico**.

### Extraindo informações

Neste caso, usaremos uma biblioteca que já vem com o Dart. **Não precisamos instalá-la**, **apenas a importar** para o código. Essa biblioteca **converte a string JSON em um objeto**, como uma lista ou um Map, automaticamente.

**Fazemos outro import no topo do arquivo** `main.dart` abaixo do anterior:

```dart
import 'dart:convert';
```

Esse `convert` vem do dart, mas não está presente no pacote que importamos anteriormente.

Isso porque, **ao adicionar algo ao arquivo, ele fica mais pesado**, o que pode afetar seu desempenho em dispositivos mais lentos. Com isso em mente, a equipe do Dart decidiu que, embora o `convert` seja importante, nem todo arquivo precisa usá-lo. Assim, só importamos quando necessário.

Dentro do bloco `futureResponse.then()`, abaixo da linha `print(response.body)`, criaremos uma nova linha com "Enter", na qual **usaremos um objeto chamado `json`, oriundo do `convert`**.

Ao adicionar um ponto após esse `json`, notaremos na lista de sugestões do editor que ele possui **duas funções importantes**: `decode()` e `encode()`.

A `decode()` **converte uma string JSON em um objeto dinâmico**, como uma lista de Maps. Já se quisermos fazer o **caminho inverso**, usamos `encode()`, que **transforma um objeto em JSON**.

Nesse momento, usaremos o decode(), passando `response.body` entre seus parênteses.

```dart
// main.dart:

requestData() {
    String url = "https://gist.githubusercontent.com/ricarthlima/a0eb198cb7a70696c4031e7e577de0cd/raw/356ce2c39dfd58d3d2e948d1ad87ea828544f1db/accounts.json";
    Future<Response> futureResponse = get(Uri.parse(url));
    print(futureResponse);
    futureResponse.then(
        (Response response) {
            print(response);
            print(response.body);
            decode(response.body);
        },
    );
}
```

Com isso, **ele converterá o conteúdo do body**.

Se adicionássemos esse código **fora do escopo do** `then()`, ele apresentaria um erro, pois **não teria acesso ao `response`**, que só ocorre quando o future acaba.

Por fim, salvaremos esse `decode()` numa lista de `dynamic` chamada `listAccounts`.

```dart
requestData() {
    String url = "https://gist.githubusercontent.com/ricarthlima/a0eb198cb7a70696c4031e7e577de0cd/raw/356ce2c39dfd58d3d2e948d1ad87ea828544f1db/accounts.json";
    Future<Response> futureResponse = get(Uri.parse(url));
    print(futureResponse);
    futureResponse.then(
        (Response response) {
            print(response);
            print(response.body);
            List<dynamic> listAccounts = decode(response.body);
        },
    );
}
```

Em seguida, para obter o saldo de Carla, procuramos o elemento na lista com o `name` "Carla". Poderíamos usar o `for` e percorrer um por um, mas conforme aprendemos ao lidar com listas em outros cursos, sabemos que existe o método `where()`, que **recolhe todos os elementos que satisfazem determinada condição**.

Contudo, queremos somente o **primeiro elemento**. Para isso, existe o método `firstWhere()`, que **recebe uma condição booleana**.

Ao pressionar "Ctrl + Espaço" entre seus parênteses, selecionaremos a opção `(element) =>` da lista de sugestões para **retornar um `element`, que testaremos na chave `["name"]`** para saber se é igual a "Carla" :

```dart
requestData() {
    String url = "https://gist.githubusercontent.com/ricarthlima/a0eb198cb7a70696c4031e7e577de0cd/raw/356ce2c39dfd58d3d2e948d1ad87ea828544f1db/accounts.json";
    Future<Response> futureResponse = get(Uri.parse(url));
    print(futureResponse);
    futureResponse.then(
        (Response response) {
            print(response);
            print(response.body);
            List<dynamic> listAccounts = decode(response.body);
            listAccounts.firstWhere(
                (element) => element["name"] == "Carla",
            );
        },
    );
}
```

**A resposta do `firstWhere()` é um `dynamic`**, mas sabemos pela estrutura do `json` se tratar de um `Map` que varia, cujo valor será um `dynamic`, pois pode ser do tipo `string`, `double` ou outro. Portanto, **salvaremos o resultado do `listAccounts.firstWhere()` numa variável chamada `mapCarla`**, do tipo `Map<string, dynamic>`.

Por fim, abaixo do bloco `firstWhere()`, acessaremos o saldo com um `mapCarla["balance"]` e imprimiremos esse resultado no terminal com um `print()`:

```dart
requestData() {
    String url = "https://gist.githubusercontent.com/ricarthlima/a0eb198cb7a70696c4031e7e577de0cd/raw/356ce2c39dfd58d3d2e948d1ad87ea828544f1db/accounts.json";
    Future<Response> futureResponse = get(Uri.parse(url));
    print(futureResponse);
    futureResponse.then(
        (Response response) {
            print(response);
            print(response.body);
            List<dynamic> listAccounts = decode(response.body);
            Map<String, dynamic> mapCarla = listAccounts.firstWhere(
                (element) => element["name"] == "Carla",
            );
            print(mapCarla["balance"]);
        },
    );
}
```

Após salvar, acessaremos o terminal com "Ctrl + J" para limpá-lo e executar o código abaixo:

```sh
dart run bin/main.dart
```

**O terminal recuperará a resposta**, fará um tratamento e mostrará os objetos seguidos do saldo de Carla, que é 500.

```
500.0
```

Ao conferir esse resultado no objeto de Carla, podemos constatar que o retorno está correto.

```json
{
    "id": "ID004",
    "name": "Carla",
    "lastName": "Oliveira",
    "balance": 500.0
}
```

### Conclusão

**JSON é amplamente utilizado para trafegar informações via API**. Saber que o Dart possui uma biblioteca para converter strings JSON em objetos é essencial para tornar o código mais complexo e valioso para as pessoas usuárias.