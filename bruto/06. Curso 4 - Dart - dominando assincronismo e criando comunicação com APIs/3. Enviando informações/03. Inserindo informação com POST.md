## Inserindo informação com POST

Agora que sabemos adicionar um novo dado à lista que recebemos, chegou a hora de **enviá-la para o servidor**.

*Seria apenas chamar aquele mesmo GET e passar esse `content`, além da URL, para que ele receba e substitua?* Vamos testar.

Vamos copiar a linha de `String url` inserir ela como substituição à linha do `print(content)`.

```dart
sendDataAsync(Map<String, dynamic> mapAccount) async {
  List<dynamic> listAccounts = await requestDataAsync();
  listAccounts.add(mapAccount);
  String content = json.encode(listAccounts);

  String url = "https://api.github.com/gists/413c0aefe6c6abc464581c29029c8ace";
```

Em seguida, faremos um `get` passando nosso `content`.

```dart
get(Uri.parse(url), content);
```

A **IDE está indicando um erro no `content`**. Ao deixar o mouse sobre ele, aparece a mensagem:

```
Too many positional arguments: 1 expected, but 2 found. Try removing the extra positional arguments, or specifying the name for named arguments.dart(extra_positional_arguments_could_be_named)

String content

Type: String
```

O erro indica que temos **argumentos posicionais demais**. Ele esperava um argumento, mas enviamos dois.

Isso faz sentido, pois o **GET esperava apenas a URL**, que é para quem ele deve pedir alguma coisa.

O verbo **GET**, que vem do inglês "pegar" ou "obter", é usado no HTTP **apenas para obter informações**. Idealmente, o GET é apenas para **solicitar informações**, embora, dependendo de como o servidor seja configurado, seja possível fazer alterações usando o GET. Mas, idealmente, usamos o GET somente para pedir informações.

### POST

Quando falamos de HTTP, não nos referimos apenas ao pacote HTTP que instalamos no Dart, mas ao próprio protocolo HTTP que baseia esse pacote. Um dos verbos que podemos usar para fazer alterações é o `POST`. O POST é usado para **fazer uma postagem ou adicionar algo**. Vamos substituir o GET na linha por um POST:

```dart
post(Uri.parse(url), content);
```

O que queremos enviar para o servidor, para que ele faça algum tratamento, fica no `body`. Esperamos que, quando chegar ao servidor do gist, ele faça essa substituição para nós. Se passarmos o mouse sobre o `post`, veremos que ele retorna um `future response`. Já sabemos lidar com isso. Vamos fazer o seguinte:

```dart
Response response = await post(Uri.parse(url), body: content);
```

Para finalizar, vamos imprimir `response.body` para ver qual é a resposta que ele nos dá e verificar se é uma resposta positiva.

```dart
Response response = await post(Uri.parse(url), body: content);
print(response.body);
```

### Testando

Vamos salvar, abrir o terminal e executar o comando para verificar o que acontecerá.

```sh
dart run bin/main.dart
```

**Ele retornou um print enorme com informações aleatórias**. Não era o que esperávamos. Sabemos que é um HTML, uma página da web, e nosso print não está preparado para lidar com isso. **Algo deu errado**. Vamos ver se conseguimos alguma pista do que deu errado. Em vez de imprimir o `body`, vamos imprimir o `statusCode`.

```dart
Response response = await post(Uri.parse(url), body: content);
print(response.statusCode);
```

**O status code existe no HTTP, tanto no pacote quanto no protocolo,** e indica **se algo deu certo ou não através de um código numérico de três dígitos**. Vamos ver se ele dá algum código diferente de 200. Os códigos 200, 201 ou 202. Se não está na faixa de 200 a 299, sabemos que é um erro.

Vamos salvar, abrir o terminal, e executar novamente.

```sh
dart run bin/main.dart
```
```
403
```

Ele retornou um 403. *O que é o 403 especificamente?* Podemos consultar a página do MDN, que é muito útil para verificar informações sobre o protocolo HTTP.

```
403 Forbidden

O código de resposta de status de erro do cliente HTTP 403 Forbidden indica que o servidor entendeu o pedido, mas se recusa a autorizá-lo.

Esse status é semelhante ao 401 , mas neste caso, a re-autenticação não fará diferença. O acesso é permanentemente proibido e vinculado à lógica da aplicação (como uma senha incorreta).
```

O que isso significa para nós? O servidor entendeu que estamos tentando alterar esse gist, mas não podemos fazer isso. Por quê? Imagine: se alguém conseguisse editar apenas com esse código no Dart, seria uma falha de segurança imensa, pois qualquer pessoa poderia editar um gist da nossa empresa. O servidor do GitHub impede isso, **pois não sabe quem somos**.

### Próximo passo

Precisamos provar ao GitHub que quem está tentando editar esse gist **é a pessoa a quem ele pertence**.

Para isso, **precisamos de uma chave de autorização**, uma chave de API (API Key). É justamente isso o que faremos no próximo vídeo!