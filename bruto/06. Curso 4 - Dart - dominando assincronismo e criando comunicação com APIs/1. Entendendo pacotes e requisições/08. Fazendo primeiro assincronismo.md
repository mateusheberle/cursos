## Fazendo primeiro assincronismo

Agora que realizamos nossa primeira requisição, é hora de **capturarmos a resposta**.

### Capturando a resposta da requisição

Quando fizemos a requisição com o método `get()` e colocamos o resultado no `print()`, notamos que ele apareceu como uma **instância do futuro** de uma resposta. No entanto, queremos os dados das contas de fato. Para obter isso, o segredo está nos termos `Future` e `Response`.

#### O que é o `Response`?

Começaremos falando sobre a **resposta**, isto é, o `Response`.

O `Response` é um **objeto criado no `http` para organizar a resposta**. 

**Quando um servidor**, como o do Gist do GitHub, **nos envia uma resposta**, **ele não manda apenas o arquivo ou o dado que queremos**, mas uma **série de outros dados** sobre a comunicação, o que chamados de **metadados**.

Os metadados incluem informações como: **se houve algum problema**; o **tipo de arquivo**; o **tempo que levou**; entre outras. Para organizar isso, o http criou o objeto Response que iremos utilizar.

#### Criando o objeto `Response`

Para começar, vamos remover o `print()` do método `get()`.

Antes do método `get()` ser utilizado no arquivo `main.dart`, na mesma linha, vamos criar um novo objeto do tipo `Response` chamado `response`.

```dart
// main.dart:

// código omitido

requestData() {
  String url = "https://gist.githubusercontent.com/ricarthlima/a0eb198cb7a70696c4031e7e577de0cd/raw/356ce2c39dfd58d3d2e948d1ad87ea828544f1db/accounts.json";
  Response response = get(Uri.parse(url));
}
```

Nesse caso, **será retornado um erro** em vermelho no código.

Sempre que **algo estiver em vermelho**, é importante **ler a instrução com calma**, pois as informações são exibidas pela ferramenta **para nos ajudar**.

O erro diz que o valor do tipo `Future<Response>` não pode ser atribuído a uma variável do tipo `Response`. Portanto, cometemos um erro ao dizer que a variável que receberia o resultado seria uma `Response`, pois, segundo o Dart, não é apenas uma `Response`, mas sim uma `Future<Response>`.

**Pode parecer abstrato**, mas a ideia de futuro com uma resposta faz sentido no Dart. **Quando fazemos um pedido para o servidor**, **ele percorre um longo caminho**:

#### Utilizando o `Future`

O Dart **precisa estar preparado** para situações em que **a resposta não é instantânea**. Nesse momento, surge o conceito de **assincronismo**, isto é, **algo que não acontece simultaneamente**.

Essa é a beleza do `Future` que o método `get()` retorna. Com base nesses conhecimentos, vamos seguir o que é solicitado e substituir o tipo `Response` por `Future` contendo uma `Response`.

**O `Future`**, diferentemente do `Response`, **não é do pacote `http`**, **mas do Dart**, pois, em várias situações, não apenas em comunicação com Web API, enfrentamos atrasos.

O Dart **precisa se preparar para isso**, então vamos imprimir o resultado. Porém, antes disso, vamos mudar o nome do objeto: em vez de `response`, teremos `futureResponse`.

Para finalizar, adicionamos `print(futureResponse)` na linha abaixo.

```dart
// código omitido

requestData() {
  String url = "https://gist.githubusercontent.com/ricarthlima/a0eb198cb7a70696c4031e7e577de0cd/raw/356ce2c39dfd58d3d2e948d1ad87ea828544f1db/accounts.json";
  Future<Response> futureResponse = get(Uri.parse(url));
  print(futureResponse);
}
```

### Testando o código

Após salvar as alterações, vamos abrir o terminal e executar o seguinte comando:

```sh
dart run bin/main.dart
```

O **resultado foi o mesmo**: uma **instância do futuro da resposta**.

```
Instance of Future<Response>
```

Embora tenhamos entendido o que é o `Future` contendo a `Response`, passar `futureResponse` para um `print()`, ou usar o `get()` e o retorno dela em um `print()`, geram os mesmos resultados.

### Conclusão

Agora, **falta pedir para o Dart fazer algo quando a operação terminar**, isto é, **quando os dados retornarem do servidor**.

