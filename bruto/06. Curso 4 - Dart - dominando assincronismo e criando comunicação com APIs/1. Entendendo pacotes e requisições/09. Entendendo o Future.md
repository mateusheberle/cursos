## Entendendo o `Future`

Temos o `Future` em mãos, um objeto que **representa uma operação assíncrona** no Dart. No entanto, não adianta apenas imprimi-lo. Só conseguiremos o que queremos, isto é, o arquivo `accounts.json`, quando **tivermos acesso ao que está dentro do `Future`**, que é **a `Response`**.

Conseguimos o acesso justamente **quando a operação assíncrona termina**. Por isso, mencionamos tantas vezes a palavra **"quando"**: para manter o pensamento a respeito do tempo.

Em algum momento, **todo `Future` no Dart termina**, e quando isso acontece, podemos **coletar o resultado dessa operação** e, a partir disso, fazer algo com ele.

### Capturando o resultado da operação

#### Utilizando o método `then()`

Com o arquivo `main.dart` aberto, abaixo do `print()` de `futureResponse`, vamos chamar novamente `futureResponse`, seguida do **método `then()`**, para **obtermos a resposta quando o `Future` terminar**.

O método `then()` vem do inglês e significa **"e então"**.

Assim, **quando o `Future` terminar**, **poderemos fazer algo** efetivamente. Portanto, entre os parênteses de `then()`, precisamos passar o que queremos que aconteça ao final do `Future`.

```dart
// main.dart:

// código omitido

requestData() {
  String url =
      "https://gist.githubusercontent.com/ricarthlima/a0eb198cb7a70696c4031e7e577de0cd/raw/356ce2c39dfd58d3d2e948d1ad87ea828544f1db/accounts.json";
  Future<Response> futureResponse = get(Uri.parse(url));
  print(futureResponse);
  futureResponse.then();
}
```

#### Criando uma função anônima

No lugar do `onvalue`, adicionado automaticamente pelo VS Code, podemos usar o atalho **"Ctrl + Espaço"** para **obter uma sugestão de código**. 

Normalmente, as **duas primeiras sugestões são as que importam**. Nesse caso, temos:

- Uma função do tipo arrow (`(value) =>`);
- Ou uma função do tipo normal (`(value) {}`).

Para este cenário, optaremos por usar a **função normal**. Selecionada a sugestão, **tudo que estiver no escopo dessa função anônima será executado ao término do `Future`**.

```dart
// código omitido

requestData() {
  String url =
      "https://gist.githubusercontent.com/ricarthlima/a0eb198cb7a70696c4031e7e577de0cd/raw/356ce2c39dfd58d3d2e948d1ad87ea828544f1db/accounts.json";
  Future<Response> futureResponse = get(Uri.parse(url));
  print(futureResponse);
  futureResponse.then(
    (value) {
    
    },
  );
}
```

Por padrão, o valor vem como `value` para qualquer tipo de `Future`, seja um futuro que tem uma resposta ou qualquer outro elemento. Ele vem como um `value` simples, que não nos diz nada. Entretanto, na programação, muitas vezes, **queremos que nossas variáveis sejam descritivas**.

Sendo assim, em vez de utilizarmos o valor `value`, adicionaremos um objeto do tipo `Response` chamado `response`. **O nome é indiferente, enquanto o tipo importa**, então passamos o tipo preparado no método `get()`, onde a resposta do `Future` é uma `Response`.

Se colocássemos, por exemplo, uma `String` no lugar do tipo `Response`, haveria um erro, pois o método `get()` foi programado de outra forma. **Usamos `Response` para deixar nítido o que recebemos como resposta quando o `Future` termina**. Poderíamos usar o `value` diretamente no dia a dia, mas **a melhor prática é deixar tudo evidente**, para que outras pessoas com acesso ao código entendam que o resultado da operação assíncrona é uma resposta.

Por fim, vamos imprimir o objeto `response` com `print()`.

```dart
// código omitido

requestData() {
  String url =
      "https://gist.githubusercontent.com/ricarthlima/a0eb198cb7a70696c4031e7e577de0cd/raw/356ce2c39dfd58d3d2e948d1ad87ea828544f1db/accounts.json";
  Future<Response> futureResponse = get(Uri.parse(url));
  print(futureResponse);
  futureResponse.then(
    (Response response) {
      print(response);
    },
  );
}
```

Com isso, finalmente, temos a resposta do `get()` em mãos.

#### Testando o código

Após salvar o arquivo, podemos abrir o terminal e executar o seguinte comando:

```sh
dart run bin/main.dart
```

Note que o processo demanda tempo, ou seja, **não é instantâneo**. Primeiramente, **esperamos certo tempo para receber o futuro da resposta**, e depois disso ele imprime uma resposta.

Como retorno, **recebemos a mensagem "Instance of Response"**, que também não significa nada para nós. Você pode estar se perguntando: por que ainda não recebemos o arquivo `accounts.json`?

### Ajustando o código de main.dart

Anteriormente, falamos que o objeto `Response` do pacote `http` é uma classe criada para **organizar a resposta do servidor**, pois não recebemos apenas o arquivo necessário, mas também informações sobre comunicação, como cabeçalhos, a duração, se deu certo ou não, e assim por diante.

O problema que acontece é que tentamos imprimir um objeto complexo, mas **queremos apenas o conteúdo dele**, isto é, o que está no corpo da resposta. Para solucionar isso, basta adicionar um novo `print()` no escopo de `then()`, recebendo `response.body` entre parênteses.

```dart
// main.dart:

// código omitido

requestData() {
  String url =
      "https://gist.githubusercontent.com/ricarthlima/a0eb198cb7a70696c4031e7e577de0cd/raw/356ce2c39dfd58d3d2e948d1ad87ea828544f1db/accounts.json";
  Future<Response> futureResponse = get(Uri.parse(url));
  print(futureResponse);
  futureResponse.then(
    (Response response) {
      print(response);
      print(response.body);
    },
  );
}
```

Uma vez salvas as alterações, retornaremos ao terminal para executar o comando novamente:

```sh
dart run bin/main.dart
```

Agora, recebemos, de fato, todos os `print()` adicionados em código:

```json
// accounts.json:

[
    {
        "id": "ID001",
        "name": "Ricarth",
        "lastName": "Lima",
        "balance": 113.0
    },

    // código omitido

    {
        "id": "ID010",
        "name": "Isabela",
        "lastName": "Almeida",
        "balance": 210.0
    }
]
```

Em relação ao primeiro `print()`, de um `Future` com uma `Response`, esperamos o `Future` acontecer, obtivemos a resposta, e no escopo do objeto `Response`, encontramos, finalmente, o corpo da resposta, que vem com o arquivo `accounts.json` formatado como uma lista de contas.

### Conclusão

O que fizemos é muito gratificante, pois a comunicação com o mundo externo, obtendo algo que não é apenas inerente do nosso código, mas também usando um pacote de terceiros, é algo fascinante.
