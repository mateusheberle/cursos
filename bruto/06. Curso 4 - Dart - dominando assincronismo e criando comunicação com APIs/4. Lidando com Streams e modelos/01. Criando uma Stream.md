## Criando uma `Stream`

**Conseguimos tanto receber quanto enviar informações**, o que é excelente! No entanto, há um problema crítico e muito importante de boa prática que precisamos resolver em nossas funções.

**A responsabilidade de uma função que se comunica com uma API deve ser apenas essa comunicação**. A boa prática recomenda **separar as funções**, e, por isso, esses prints espalhados em todas as nossas funções não deveriam estar presentes. Eles deveriam ser responsabilidade de outra parte do código, que não as funções de comunicação com a API. Vamos resolver isso!

### Entendendo as `Streams`

Existem inúmeras formas de resolver essa questão e trazer essas informações para um ambiente externo à função de comunicação com a API. Vamos optar por uma abordagem que será muito útil e conveniente para demonstrar outra forma de assincronismo no Dart. Além do `Future`, que é uma **forma de assincronismo no Dart**, utilizaremos também as **`Streams`**.

As `Streams` têm algo a ver com o que vemos, por exemplo, na **Twitch** ou no **YouTube**, em transmissões ao vivo, e entenderemos isso melhor conforme implementamos o exemplo.

### Criando um `StreamController`

A primeira etapa para utilizar uma `Stream` é **criar um controlador de `Stream`, o `StreamController`**. Ele funciona como o próprio **streamer**, **a pessoa que controla tudo o que acontece durante uma transmissão ao vivo**. É exatamente isso que faremos!

**Acima da função `main()`**, **criaremos um `StreamController`** e **especificaremos o tipo `String`**. Essa especificação indica que as informações que receberemos nesse `Stream` serão do tipo `String`.

```dart
StreamController<String>
```

### Entendendo a diferença entre `Future` e `Stream`

Enquanto no **`Future` você realiza uma operação**, **obtém os dados necessários e encerra**, no `Stream` isso não acontece. **Um `Stream` permanece aberto, enviando informações sempre que necessário**.

Imagine que você tem um streamer famoso, alguém que faz transmissões ao vivo, e essa pessoa te envia um e-mail. Você recebe o e-mail e a interação termina ali. Isso é semelhante ao `Future`. **No `Future`, você abre um canal, lê o e-mail e encerra**.

Já o `Stream` é como se essa pessoa estivesse fazendo uma transmissão ao vivo, e você estivesse assistindo. **Ela está sempre enviando novas informações**, falando e mostrando coisas. Essa é a diferença!

### Inicializando o StreamController

Vamos criar um `streamController` inicializando como `StreamController<String>()`. É uma boa prática **especificar na inicialização que a informação enviada será do tipo `String`**.

```dart
StreamController<String> streamController = StreamController<String>();
```

### Próximos passos

Com isso, é como se **tivéssemos configurado a pessoa criadora de conteúdo**, que seria o **streamer**. O próximo passo é ouvirmos, como se estivéssemos abrindo a transmissão ao vivo. Vamos fazer isso na sequência!