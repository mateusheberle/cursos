## Para saber mais: avançando em `streams`

Explorando o poder das Streams no Dart!

**Streams** é uma ferramenta que **permite lidar com fluxos contínuos de dados de forma assíncrona**, no Dart. Aprendemos como **usar `add` e `listen` para enviar e ouvir dados**, mas o Dart oferece muitas outras possibilidades que podem tornar seu código ainda mais eficiente e flexível.

Vamos explorar algumas dessas funcionalidades!

### Para além do `listen`

Muito mais do que só ouvir e mandar dados, o Dart oferece várias outras **formas de interagir com `streams`**. Aqui estão algumas delas:

- **Transformando `streams` com map**:

Assim como em listas, **você pode transformar cada elemento de uma stream usando o método `map`**. Por exemplo, se você está recebendo uma stream de números, pode mapear para seus quadrados:

```dart
streamController.stream.map((event) => event * event).listen((event) {
  print(event);
});
```

Esse método é especialmente útil **quando você precisa modificar os dados antes de usá-los**.

- **Filtrando `streams` com where**:

Se você precisa processar apenas certos valores de uma stream, **pode usar where para filtrar os eventos que deseja ouvir**:

```dart
streamController.stream.where((event) => event.isNotEmpty).listen((event) {
  print("Evento não vazio: $event");
});
```

Isso ajuda a garantir que **apenas os dados relevantes sejam processados**.

- **Usando `asyncExpand` para `stream` dentro de `stream`**:

Se cada evento da stream precisa gerar uma nova `stream` (por exemplo, **múltiplas requisições de API**), você pode usar `asyncExpand`:

```dart
streamController.stream.asyncExpand((event) => outraStream(event)).listen((event) {
  print("Evento da nova stream: $event");
});
```

Isso é útil em situações complexas, onde a origem dos dados pode desencadear fluxos adicionais.

- **Pausando e retomando `streams` com `pause` e `resume`**:
Se você precisar pausar o envio de eventos temporariamente, pode usar pause e resume:

```dart
StreamSubscription subscription = controller.stream.listen((event) {
  print(event);
});

subscription.pause(); // Pausa a stream
subscription.resume(); // Retoma a stream
```

Isso é útil em situações onde você **precisa controlar o fluxo de dados**, como durante operações intensivas ou ao sincronizar dados em segundo plano.

### Mais poder com o `StreamController`

Como aprendemos também, o **`StreamController` é o ponto central para criar e controlar `streams`**. Ele oferece diversas funcionalidades além de simplesmente adicionar eventos com `add`.

Aqui estão algumas possibilidades:

- **Controlando múltiplos ouvintes com `broadcast`**:

Por padrão, uma `stream` pode ter apenas um ouvinte. Mas com `StreamController.broadcast()`, **você pode permitir múltiplos ouvintes para a mesma `stream`**:

```dart
StreamController<String> controller = StreamController<String>.broadcast();
```

Isso é útil em situações onde você **precisa que vários widgets ou partes da aplicação ouçam os mesmos eventos**.

- **Sincronizando eventos com `addSync`**:

Para cenários onde a ordem de execução dos eventos é crucial e você deseja **garantir que todos os ouvintes recebam os eventos ao mesmo tempo**, **use `addSync`**:

```dart
controller.addSync("Evento sincronizado");
```

Isso é útil quando você **precisa manter a consistência dos dados em tempo real** entre diferentes ouvintes.

- **Cuidando do estado de erro com `addError`**:

**O `StreamController` permite enviar erros para os ouvintes através de `addError`**, útil para sinalizar problemas durante a transmissão de dados:

```dart
controller.addError("Ocorreu um erro");
```

Isso permite que os ouvintes lidem com erros de maneira específica, usando o callback `onError` no método listen.

### Deixando de ouvir uma `stream`

Saber quando parar de ouvir uma `stream` é tão importante quanto saber como ouvi-la!

Por exemplo, quando estamos ouvindo uma `stream` em uma instância que sabemos que será fechada no nosso programa, **precisamos parar de ouvir a `stream` antes do encerramento para evitar uso desnecessários de recursos e erros**.

O Dart oferece maneiras simples de gerenciar isso:

- **Cancelando uma inscrição**:

Se em algum momento você não precisar mais ouvir uma `stream`, pode cancelar a inscrição:

```dart
StreamSubscription subscription = streamController.stream.listen((event) {
  print(event);
});

// Para de ouvir após 5 segundos
Future.delayed(Duration(seconds: 5), () {
  subscription.cancel();
});
```

Isso é crucial **para evitar vazamento de memória em aplicativos de longa duração**.

- **Utilizando `onDone` e `onError`**:

Você pode definir ações específicas **quando a `stream` é concluída ou quando ocorre um erro**:

```dart
streamController.stream.listen(
  (event) => print(event),
  onDone: () => print("Stream finalizada."),
  onError: (error) => print("Erro na stream: $error"),
);
```

Essas opções ajudam a garantir que você lide corretamente com o fim de uma stream ou com problemas inesperados.

### Função de stream com `async*`

Outra funcionalidade interessante do Dart é a capacidade de criar funções assíncronas que retornam `streams` usando o `async*`.

Isso é útil para **gerar fluxos de dados de forma mais controlada e com pausas entre cada evento**. Vamos imaginar que você queira gerar uma série de números, mas com um intervalo entre cada um:

```dart
Stream<int> numeros() async* {
  for (int i = 0; i < 5; i++) {
    await Future.delayed(Duration(seconds: 1));
    yield i;
  }
}
```

Aqui, a função numeros retorna uma stream que emite valores de 0 a 4, com um segundo de intervalo entre cada um.

O uso de `yield` é o que torna essa função tão poderosa, **permitindo que você produza novos eventos de forma controlada e pausada**.

Para se aprofundar ainda mais nesse assunto, recomendo a [leitura da documentação oficial do Dart](https://dart.dev/libraries/async/creating-streams) que detalha o uso de Streams com exemplos práticos e avançados.