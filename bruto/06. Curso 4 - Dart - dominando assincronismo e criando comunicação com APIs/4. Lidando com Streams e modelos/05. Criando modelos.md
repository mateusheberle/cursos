## Criando modelos

Até agora, adquirimos bastante conhecimento! Aprendemos a utilizar dois tipos de assincronismo no Dart e a realizar comunicações com APIs, tanto para solicitar quanto para enviar dados. Vamos analisar nosso projeto.

As funções estão operando corretamente, mas há aspectos que podemos aprimorar em termos de **boas práticas**, e precisamos finalizá-las. Devemos utilizá-las para que os usuários possam se comunicar e obter informações das contas. Vamos prosseguir?

### Criando um Model

O primeiro passo é **construir um modelo de conta**, **um model**. Normalmente, utilizamos esses modelos para **representar algum conceito da vida real**. No nosso caso, temos a conta, **`Account`, que estamos manipulando. Estamos tanto recebendo quanto enviando dados**, mas lidamos com o `Account` através de um `map`. Isso é útil para a transmissão dos dados, especialmente no contexto do JSON, mas seria mais interessante **transformar isso em uma classe**.

Ao transformar isso em uma classe, estamos criando um modelo que representa o conceito da realidade que queremos trabalhar e utilizar no nosso projeto. Vamos criar esse modelo.

Com o VS Code aberto, pressionamos "Ctrl + B" para abrir o explorador. Em seguida, clicamos com o botão direito do mouse sobre a pasta `lib`, e criamos uma **nova pasta** selecionando a opção "New Folder". Vamos chamá-la de **`models`**, que é um padrão comum.

Existem vários padrões para organizar arquivos em projetos Dart e Flutter, dependendo do design de arquitetura que queremos usar e de como a empresa está trabalhando. No entanto, seguiremos um padrão que contempla a maioria dos casos, que é criar uma pasta `models` e, dentro dela, **criar um arquivo chamado `account.dart`**.

### Criando a classe `Account`

Neste arquivo, **criamos uma classe chamada `Account`**. Vamos relembrar quais atributos essa classe precisa ter, já que ela representará os dados que virão via map. A classe deve incluir uma String id para representar o ID, uma String name para o nome do titular da conta, uma String lastName para o sobrenome, e, por fim, um double balance para o saldo da conta.

```dart
class Account {
  String id;
  String name;
  String lastName;
  double balance;
}
```

### Criando o construtor

Com os atributos definidos, **o próximo passo é criar o construtor**. Vamos começar com o **construtor mais simples**, que inicializa esses atributos. Utilizaremos **parâmetros nomeados**, pois **são mais descritivos**.

```dart
Account({
    required this.id,
    required this.name,
    required this.lastName,
    required this.balance,
  });
```

Normalmente, pararíamos por aqui. Temos nossos atributos e nosso construtor, e não há nenhum método específico relacionado à conta que queremos criar neste momento. No entanto, como estamos lidando com tráfego de dados, onde **sempre precisamos converter essas informações para um `map` para enviar ao servidor ou pegar um `map` que veio do servidor e converter para esse modelo**, é comum que, ao criar um model que trafegará dados pela internet, façamos algo chamado de `DataClass`. Vamos transformar essa classe em algo que possamos manipular dados.

### Implementando `fromMap` e `toMap`

Para começar, **precisamos de um construtor que, a partir de um map, consiga inicializar um `Account`, e de um método que, dado um objeto `Account`, o transforme em um map**. Assim, não precisaremos fazer isso em um futuro serviço ou tela, mas sim aqui mesmo no model. Vamos fazer isso.

Primeiro, criaremos um construtor especial. Normalmente, para criar um construtor especial, usaríamos `Account.fromMap` e passaríamos `Map<String, dynamic> map`. Para inicializar os atributos, usaríamos dois pontos e inicializaríamos via `map`.

No entanto, vamos usar um termo especial do Dart chamado **`factory` (fabricar), que nos permite criar um construtor a partir de outro**. Com o uso do `factory`, conseguimos criar um construtor especial utilizando outro já existente. Agora, precisamos apenas transformar o `map` que está vindo por parâmetro nos valores que queremos passar para inicializar o objeto `Account`.

```dart
factory Account.fromMap(Map<String, dynamic> map) {
    return Account(
      id: map['id'] as String,
      name: map['name'] as String,
      lastName: map['lastName'] as String,
      balance: map['balance'] as double,
    );
```

Para o caminho inverso, ou seja, **pegar um `Account` já inicializado e transformá-lo em um `map`**, criaremos um **método `toMap()`**. **Usaremos as mesmas chaves utilizadas em `fromMap`**.

```dart
Map<String, dynamic> toMap() {
    return <String, dynamic>{
      'id': id,
      'name': name,
      'lastName': lastName,
      'balance': balance,
    };
```

**Os nomes `fromMap` e `toMap` são convenções amplamente utilizadas**, por isso recomendamos seu uso. Com isso, criamos um modelo para nossa conta.