## Enviando dados para a `Stream`

**A stream está criada, o canal está configurado e estamos ouvindo**. **Falta apenas a parte de enviar as informações** a serem transmitidas!

### Removendo prints das funções

Nosso objetivo principal é organizar os comandos de `print`. No futuro, quando alguém estiver usando nossa aplicação bancária e fizer uma requisição, será necessário saber que uma requisição foi feita. Mas essa não é a responsabilidade das nossas funções de comunicação com a API. **Precisamos remover todos esses prints que usamos para entender o que estava acontecendo e substituí-los por informações mais claras**. É exatamente isso que vamos fazer!

Vamos procurar cada `print` em todas as funções. Na função `requestData()`, vamos remover `print(futureResponde)`, pois serviu apenas para sabermos o que estava chegando. Depois, há `print(mapCarla["balance"])`, que foi apenas um exemplo e também será removido. Ao fazer isso, o código indica que `mapCarla` não está sendo usado, então podemos removê-lo. Com a remoção de `mapCarla`, o `listAccounts` também não é mais necessário e será deletado.

Além disso, há dois `prints`, um quando a resposta chega e outro do próprio corpo da requisição, que também deve ser removidos. Após o `.then()`, há um último print para testar a última coisa que acontece quando usamos `.then()`. Vamos deletá-lo.

```dart
requestData() {
  String url =
      "https://gist.githubusercontent.com/ricarthlima/a0eb198cb7a70696c4031e7e577de0cd/raw/356ce2c39dfd58d3d2e948d1ad87ea828544f1db/accounts.json";
  Future<Response> futureResponse = get(Uri.parse(url));
  futureResponse.then(
    (Response response) {},
  );
}
```

Na função `requestData`, já não há mais nenhum `print`. Ao final da função de enviar os dados, há um `print(responde.statusCode)` que também deve ser removido.

**Esses elementos foram removidos porque não são responsabilidade das nossas funções de comunicação com a API**. No entanto, elas ainda precisam se comunicar de alguma forma para informar o que está acontecendo. Quem estiver ouvindo nosso stream precisa mostrar isso para a pessoa usuária que está utilizando nossa aplicação. Para isso, nos locais **onde havia `prints`, vamos utilizar o método `add` do `streamController`**.

### Enviando dados pela Stream

Começando na função `requestData`, após o `.then()`, ou seja, **quando terminar de processar a requisição, vamos chamar o `streamController`**. **Utilizaremos o método `add` para passar um evento**.

Ao criar o `streamController`, combinamos que os dados trafegados seriam sempre do tipo `string`. Portanto, passaremos uma `string`. Se fosse outro tipo de `streamController`, seria outro tipo de objeto no `add`. No nosso caso, é uma `string`.

**Vamos passar uma informação útil, como o momento exato, a data e a hora de uma operação**. Para isso, faremos uma interpolação com o cifrão, chamando `DateTime.now`. Adicionaremos um espaço, uma barra vertical por estética, e descreveremos o que aconteceu: "Requisição de leitura (usando then)".

```dart
requestData() {
  String url =
      "https://gist.githubusercontent.com/ricarthlima/a0eb198cb7a70696c4031e7e577de0cd/raw/356ce2c39dfd58d3d2e948d1ad87ea828544f1db/accounts.json";
  Future<Response> futureResponse = get(Uri.parse(url));
  futureResponse.then(
    (Response response) {
      streamController
          .add("${DateTime.now()} | Requisição de leitura (usando then).");
    },
  );
}
```

**Quando chamamos `streamController.add`, ele envia essa informação pelo canal, tornando-a disponível para todos que se inscreveram na `stream`**. Se houver uma inscrição em outra parte do código, a informação também chegará lá. **Várias partes do código podem usar o método `listen` para ouvir de uma `stream`**. Essa é uma das vantagens do `streamController` e do uso de streams em geral.

Vamos copiar as linha que acabamos de implementar e colá-las na função `requestDataAsync`, alterando apenas a descrição para "Requisição de leitura", pois nosso padrão é que o método seja assíncrono.

```dart
Future<List<dynamic>> requestDataAsync() async {
  String url =
      "https://gist.githubusercontent.com/ricarthlima/a0eb198cb7a70696c4031e7e577de0cd/raw/356ce2c39dfd58d3d2e948d1ad87ea828544f1db/accounts.json";
  Response response = await get(Uri.parse(url));
  streamController.add("${DateTime.now()} | Requisição de leitura.");
  return json.decode(response.body);
}
```

Agora, copiaremos essa linha e faremos uma modificação na função `sendDataAsync`.

Apenas anotar que a requisição terminou, dependendo do que passamos, pode causar problemas, refletidos no `statusCode`. Então, **logo após fazer o `Response`, faremos uma verificação utilizando `response.statusCode`** e convertemos para string para pegar o primeiro caractere. **Se for igual a 2, significa que qualquer número entre 200 e 299 será 2**.

Em seguida, colamos a linha copiada dentro da condicional e alteramos a descrição para Requisição adição bem sucedida `(${mapAccount["name"]}).")`. Utilizamos uma interpolação para exibir o name que tentamos adicionar.

```dart
if (response.statusCode.toString()[0] == "2") {
    streamController.add(
        "${DateTime.now()} | Requisição adição bem sucedida (${mapAccount["name"]}).");
```

Na sequência, **inserimos um else para o caso de falha**. Nele, replicamos a linha copiada alterando a descrição para Requisição falhou `(${mapAccount["name"]}).")`.

```dart
if (response.statusCode.toString()[0] == "2") {
    streamController.add(
        "${DateTime.now()} | Requisição adição bem sucedida (${mapAccount["name"]}).");
  } else {
    streamController
        .add("${DateTime.now()} | Requisição falhou (${mapAccount["name"]}).");
  }
}
```

### Removendo comentários da função `main()`

Vamos salvar e, na função `main()`, **remover os comentários de todas as funções** anteriormente comentadas, pois queremos que todas sejam executadas.

```dart
void main() {
  StreamSubscription streamSubscription = streamController.stream.listen(
    (String info) {
      print(info);
    },
  );

  requestData();
  requestDataAsync();
  sendDataAsync({
    "id": "NEW001",
    "name": "Flutter",
    "lastName": "Dart",
    "balance": 5000,
  });
}
```

### Executando o código e verificando os resultados

Sem prints para desorganizar, cada função lançará algo na nossa stream e nossa inscrição estará preparada para capturar e mostrar na tela. Vamos rodar e verificar se funciona. Com **"Ctrl + J", abrimos o terminal**, teclamos seta pra cima para selecionar o último comando e executamos.

Podemos comparar os tempos de acordo com o retorno.

Na linha 16, a primeira coisa que pedimos foi uma informação usando o `.then()`, que ocorreu décimos de segundos depois. **Primeiro, ocorreram as duas requisições de leitura normal usando o `async`**. São duas, porque, para enviar informação, é necessário primeiro obter os dados para fazer uma alteração e depois enviá-los. **Por último, a adição foi bem-sucedida** e adicionamos algo com o nome de Flutter. Isso é excelente!

Pense nas possibilidades de onde **podemos lançar informações usando a `Stream` e capturar informações em várias partes do código**. Esse é o poder da ferramenta de assincronismo do Dart, que é a `Stream`!


