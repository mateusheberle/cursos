## Ouvindo uma `Stream`

**Criamos um controlador que funciona como uma pessoa que faz uma transmissão ao vivo**. Agora, é hora de assistirmos a essa transmissão e ouvirmos as informações que serão enviadas. *Como fazemos isso?*

### Comentando linhas da função `main()`

Vamos à nossa função `main()` e comentamos algumas linhas de código.

```dart
void main() {
  // requestData();
  // requestDataAsync();
  // sendDataAsync({
  // "id": "NEW001",
  // "name": "Flutter",
  // "LastName": "Dart",
  // "balance": 5000,
  // }); 
}
```

**Após comentar, salvamos**.

### Chamando o `StreamSubscription`

Agora, **no início da função `main()`**, antes de todo o bloco de código comentado, **chamamos o `StreamSubscription`**. É interessante notar que os termos são semelhantes aos usados em plataformas de transmissão ao vivo, onde nos inscrevemos para receber atualizações. **Quando fazemos uma `StreamSubscription`, estamos nos inscrevendo para receber atualizações** sobre novas informações assim que elas chegarem. A analogia é bastante direta e interessante.

Vamos chamar essa inscrição de `streamSubscription`, que será igual ao `streamController`. **Dentro do `streamController`, há várias funcionalidades, pois ele é o painel de controle da transmissão**, onde podemos ajustar cenas, comportamento, música, entre outros.

### Ouvindo a Stream

No entanto, como espectadores, precisamos apenas da stream para assistir. **O `streamController` possui um atributo chamado `.stream`**, que é o que vamos ouvir. Na programação, **quando estamos recebendo dados de um stream, dizemos que estamos ouvindo**. Há um método nessa stream chamado `.listen()`, que significa "ouvir" em inglês. Vamos utilizá-lo.

```dart
void main() {
  StreamSubscription streamSubscription = streamController.stream.listen(onData);
    
  // requestData();
  // requestDataAsync();
  // sendDataAsync({
  // "id": "NEW001",
  // "name": "Flutter",
  // "LastName": "Dart",
  // "balance": 5000,
  // }); 
}
```

**O `listen` é muito semelhante ao `then` do `Future`**. No `Future`, quando usamos o `then`, significa "e então?". No caso do `listen`, a ideia é a mesma, mas ao invés de **"acabou", já que a stream não necessariamente fecha na primeira interação**, significa "chegou algo novo, faça alguma coisa".

Se formos ao `onData`, no método `.listen()`, apagarmos e pressionarmos "Ctrl + Espaço", veremos as sugestões que o Dart oferece. Quando um evento chega, podemos tratar o que acontecerá com esse evento, seja com uma função arrow ou uma função normal. Vamos usar a função normal.

```dart
void main() {
  StreamSubscription streamSubscription = streamController.stream.listen(event) {
    
    },);
    
  // requestData();
  // requestDataAsync();
  // sendDataAsync({
  // "id": "NEW001",
  // "name": "Flutter",
  // "LastName": "Dart",
  // "balance": 5000,
  // }); 
}
```

### Modificando o nome do evento

Se passarmos o mouse sobre o método, **veremos que é semelhante ao `then`.** No `Future`, poderíamos ver que ele poderia retornar um `response`, e poderíamos mudar o `value` que aparecia para `response`, chamando a classe `response` com o objeto `response`. Aqui é o mesmo. O `event` é basicamente um nome lambda que podemos mudar para qualquer coisa que faça sentido para nós, contanto que seja do tipo `String`.

Quando criamos o controlador, especificamos que o tipo seria `String`, porque a informação enviada seria desse tipo. É justamente esse dado que estamos recebendo no método `.listen()`. Então, vamos substituir `event` por `String info` para ficar mais claro. A informação que está chegando poderia ser chamada de `data`, mas será uma informação, então vamos usar `String info`.

```dart
void main() {
  StreamSubscription streamSubscription = streamController.stream.listen(String info) {
    
    },);
```

Em muitas situações, especialmente ao usar pacotes como o do Firebase, veremos um uso extensivo de strings. **Precisaremos processar as informações recebidas conforme nossa regra de negócio**.

### Exibindo a informação

No nosso caso, estamos substituindo aqueles `prints`, trazendo-os para dentro da função `main` e removendo-os das funções que se comunicam com a API. Queremos imprimir na tela, então usaremos `print(info)`. Isso significa que, **quando alguém enviar uma informação por esse canal, que é a `stream`, e ela chegar na nossa função `main()` que está ouvindo, será impresso na tela**.

```dart
void main() {
  StreamSubscription streamSubscription = streamController.stream.listen(String info) {
        print(info);
    },);
```

Pronto, a informação foi impressa!

### Próximos passos

**O que falta agora é alguém de fato enviar os dados**, porque se simplesmente salvarmos, pressionarmos "Ctrl + J" e rodarmos, nada acontecerá. Apesar de o canal estar criado e estarmos ouvindo o canal, **o criador de conteúdo ainda não está enviando nada**, **a transmissão ao vivo ainda não começou**. Precisamos aprender a enviar os dados pelo canal, pela stream, e é justamente o que faremos na sequência!