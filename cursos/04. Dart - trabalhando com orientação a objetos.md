4. Curso
# Dart: trabalhando com orientação a objetos

[Link Alura](https://cursos.alura.com.br/course/dart-trabalhando-orientacao-objetos)

## Sumário

- [Dart: trabalhando com orientação a objetos](#dart-trabalhando-com-orientação-a-objetos)
  - [Sumário](#sumário)
- [01. Criando uma conta](#01-criando-uma-conta)
  - [Criando a primeira classe com Dart](#criando-a-primeira-classe-com-dart)
    - [Classe](#classe)
    - [Classe construtora](#classe-construtora)
  - [Criando objetos, acessando valores e guardando contas](#criando-objetos-acessando-valores-e-guardando-contas)
    - [Alterando os valores das variáveis](#alterando-os-valores-das-variáveis)
  - [O que é Programação Orientada a Objetos (POO)](#o-que-é-programação-orientada-a-objetos-poo)
    - [Classes:](#classes)
    - [Objeto](#objeto)
      - [**Classe**: Molde ou planta da casa.](#classe-molde-ou-planta-da-casa)
      - [**Objeto**: Casa construída e mobiliada.](#objeto-casa-construída-e-mobiliada)
    - [Instanciação](#instanciação)
  - [Para saber mais: atributos nomeados em construtores no Dart](#para-saber-mais-atributos-nomeados-em-construtores-no-dart)
  - [Mão na massa: vendendo receitas](#mão-na-massa-vendendo-receitas)
  - [Lista de exercícios](#lista-de-exercícios)
    - [01. Criando uma classe para itens de estoque.](#01-criando-uma-classe-para-itens-de-estoque)
    - [01. Resposta](#01-resposta)
    - [02. Implementando operações de entrada e saída de estoque.](#02-implementando-operações-de-entrada-e-saída-de-estoque)
    - [02. Resposta](#02-resposta)
    - [03. Gerenciando múltiplos itens de estoque.](#03-gerenciando-múltiplos-itens-de-estoque)
    - [03. Resposta](#03-resposta)
    - [04. Atualizando o preço dos itens.](#04-atualizando-o-preço-dos-itens)
    - [04. Resposta](#04-resposta)
- [02. Métodos: ações de uma conta](#02-métodos-ações-de-uma-conta)
  - [Criando funções de transferência de valores](#criando-funções-de-transferência-de-valores)
  - [Implementando métodos em uma classe Dart](#implementando-métodos-em-uma-classe-dart)
  - [Protegendo dados sensíveis com propriedades privadas](#protegendo-dados-sensíveis-com-propriedades-privadas)
    - [Separando em 2 arquivos](#separando-em-2-arquivos)
  - [Imprimindo extrato e acessando propriedades privadas](#imprimindo-extrato-e-acessando-propriedades-privadas)
  - [Para saber mais: atributos privados](#para-saber-mais-atributos-privados)
    - [01. O que são atributos privados?](#01-o-que-são-atributos-privados)
    - [02. Por que usar atributos privados?](#02-por-que-usar-atributos-privados)
  - [Lista de exercícios](#lista-de-exercícios-1)
    - [01. Criando uma classe de cliente](#01-criando-uma-classe-de-cliente)
    - [01. Resposta](#01-resposta-1)
    - [02. Realizando uma reserva de quarto](#02-realizando-uma-reserva-de-quarto)
    - [02. Resposta](#02-resposta-1)
    - [03. Cancelando uma reserva](#03-cancelando-uma-reserva)
    - [03. Resposta](#03-resposta-1)
    - [04. Protegendo os dados das reservas](#04-protegendo-os-dados-das-reservas)
    - [04. Resposta](#04-resposta-1)
- [03. Herança e polimorfismo](#03-herança-e-polimorfismo)
  - [Reaproveitando código com herança](#reaproveitando-código-com-herança)
  - [Para saber mais: outras formas de chamar superclasse](#para-saber-mais-outras-formas-de-chamar-superclasse)
    - [1ª forma:](#1ª-forma)
    - [2ª forma:](#2ª-forma)
  - [Diferenciando classes com polimorfismo](#diferenciando-classes-com-polimorfismo)
  - [Mão na massa: a equipe do bistrô](#mão-na-massa-a-equipe-do-bistrô)
  - [Aprofundando em herança e polimorfismo](#aprofundando-em-herança-e-polimorfismo)
    - [Herança e polimorfismo](#herança-e-polimorfismo)
      - [Palavras reservadas:](#palavras-reservadas)
  - [Para saber mais: mais exemplos de herança e polimorfismo](#para-saber-mais-mais-exemplos-de-herança-e-polimorfismo)
    - [1. O que é herança?](#1-o-que-é-herança)
    - [2. Por que usar herança?](#2-por-que-usar-herança)
    - [Exemplo de "animais":](#exemplo-de-animais)
    - [Como instanciar:](#como-instanciar)
  - [Lista de exercícios](#lista-de-exercícios-2)
    - [01. Criando classes de gatos e cachorros](#01-criando-classes-de-gatos-e-cachorros)
    - [01. Resposta](#01-resposta-2)
    - [02. Produzindo uma conta salário com herança](#02-produzindo-uma-conta-salário-com-herança)
    - [02. Resposta](#02-resposta-2)
    - [03. Incrementando a conta salário com polimorfismo](#03-incrementando-a-conta-salário-com-polimorfismo)
    - [03. Resposta](#03-resposta-2)
    - [04. Representando quartos com herança](#04-representando-quartos-com-herança)
    - [04. Resposta](#04-resposta-2)
    - [05. Adicionando diferenças com polimorfismo](#05-adicionando-diferenças-com-polimorfismo)
    - [05. Resposta](#05-resposta)
    - [06. Criando um método de cálculo de diárias](#06-criando-um-método-de-cálculo-de-diárias)
    - [06. Resposta](#06-resposta)
    - [07. Implementando uma classe de ingrediente](#07-implementando-uma-classe-de-ingrediente)
    - [07. Resposta](#07-resposta)
    - [8. Implementando as classes de tipos de ingrediente](#8-implementando-as-classes-de-tipos-de-ingrediente)
    - [08. Resposta](#08-resposta)
- [04. Classe abstrata](#04-classe-abstrata)
  - [Produzindo um molde com classe abstrata](#produzindo-um-molde-com-classe-abstrata)
    - [Classes abstratas](#classes-abstratas)
  - [Para saber mais: mais sobre classes abstratas](#para-saber-mais-mais-sobre-classes-abstratas)
    - [Por que usar classes abstratas?](#por-que-usar-classes-abstratas)
    - [Exemplo:](#exemplo)
  - [Aprofundando classes abstratas e entendendo interface no Dart](#aprofundando-classes-abstratas-e-entendendo-interface-no-dart)
    - [O que é classe abstrata em POO?](#o-que-é-classe-abstrata-em-poo)
    - [Interface](#interface)
  - [Para saber mais: mais sobre classe abstrata e interface](#para-saber-mais-mais-sobre-classe-abstrata-e-interface)
    - [01. O que é classe abstrata?](#01-o-que-é-classe-abstrata)
    - [02. O que é interface?](#02-o-que-é-interface)
      - [Por que usar interfaces?](#por-que-usar-interfaces)
      - [Exemplo:](#exemplo-1)
      - [Importante:](#importante)
  - [Lista de exercícios](#lista-de-exercícios-3)
    - [01. Refatorando o código das classes gato e cachorro](#01-refatorando-o-código-das-classes-gato-e-cachorro)
    - [01. Resposta](#01-resposta-3)
    - [02. Refatorando o código das reservas em hotel](#02-refatorando-o-código-das-reservas-em-hotel)
    - [02. Resposta](#02-resposta-3)
    - [03. Refatorando o código dos ingredientes](#03-refatorando-o-código-dos-ingredientes)
    - [03. Resposta](#03-resposta-3)
    - [04. Corrigindo um código com bugs](#04-corrigindo-um-código-com-bugs)
    - [04. Resposta](#04-resposta-3)
    - [05. Criando um programa de registro de funcionários](#05-criando-um-programa-de-registro-de-funcionários)
    - [05. Resposta](#05-resposta-1)
    - [06. Criando um programa informativo de espécies de seres vivos](#06-criando-um-programa-informativo-de-espécies-de-seres-vivos)
    - [06. Resposta](#06-resposta-1)
    - [07. Definindo a interface para agendamento](#07-definindo-a-interface-para-agendamento)
    - [07. Resposta](#07-resposta-1)
    - [08. Implementando a interface em uma classe de médico](#08-implementando-a-interface-em-uma-classe-de-médico)
    - [08. Resposta](#08-resposta-1)
    - [09. Implementando a interface em uma classe de dentista](#09-implementando-a-interface-em-uma-classe-de-dentista)
    - [09. Resposta](#09-resposta)
    - [10. Criando um gerenciador de agendamentos de consulta](#10-criando-um-gerenciador-de-agendamentos-de-consulta)
    - [10. Resposta](#10-resposta)
    - [11. Testando o sistema de agendamento](#11-testando-o-sistema-de-agendamento)
    - [11. Resposta](#11-resposta)
- [05. Mixins](#05-mixins)
  - [Mexendo com mixins no Dart](#mexendo-com-mixins-no-dart)
    - [Trabalhando com *Mixins* no Dart](#trabalhando-com-mixins-no-dart)
    - [Utilizando a funcionalidade **`mixin`**](#utilizando-a-funcionalidade-mixin)
    - [O que são *Mixins*](#o-que-são-mixins)
  - [Para saber mais: mais sobre mixins](#para-saber-mais-mais-sobre-mixins)
    - [O que são mixins?](#o-que-são-mixins-1)
    - [Por que usar mixins?](#por-que-usar-mixins)
  - [Princípios de POO](#princípios-de-poo)
  - [Lista de exercícios](#lista-de-exercícios-4)
    - [01. Criando um mixin para cálculo de taxa de bagagem](#01-criando-um-mixin-para-cálculo-de-taxa-de-bagagem)
    - [01. Resposta](#01-resposta-4)
    - [02. Criando uma passagem](#02-criando-uma-passagem)
    - [02. Resposta](#02-resposta-4)
    - [03. Criando um mixin para cálculo de taxa de bagagem](#03-criando-um-mixin-para-cálculo-de-taxa-de-bagagem)
    - [03. Resposta](#03-resposta-4)
    - [04. Implementando controle de acesso com mixins](#04-implementando-controle-de-acesso-com-mixins)
    - [04. Resposta](#04-resposta-4)
    - [05. Implementando controle de acesso com mixins](#05-implementando-controle-de-acesso-com-mixins)
    - [05. Resposta](#05-resposta-2)
    - [06. Produzindo uma classe de adição de produtos](#06-produzindo-uma-classe-de-adição-de-produtos)
    - [06. Resposta](#06-resposta-2)
    - [07. Melhorando a qualidade do código](#07-melhorando-a-qualidade-do-código)
    - [07. Resposta](#07-resposta-2)




# 01. Criando uma conta

**Dart** é uma linguagem voltada a **Orientação a Objetos**.

Projeto: `Anybank`.

* Banco que está passando por um processo de atualização de sistema.
* Nossa tarefa: 
  * Criar um sistema novo em Dart:
    * Com tipos de contas diferentes;
    * Funcionalidades para cada conta;
    * Imprimir saldo;
    * Realizar transferências;

## Criando a primeira classe com Dart

**1ª tarefa**: Criar conta que guarda uma informação de titular e um saldo.

### Classe
* Conjunto de informações pré-definidas.
* São como *moldes*.

```dart
void main() {

    Conta contaMateus = Conta("Mateus", 1000);
    Conta contaRoberta = Conta("Roberta", 2000);

}

class Conta {

    String titular;
    double saldo;

    Conta(this.titular, this.saldo);
    // Função construtora
    // A função 'Conta' retorna uma conta
}
```

### Classe construtora

`Conta(this.titular, this.saldo);`.

* *Função especial*.
* Uma função que serve para podermos construir essa classe.
* Não precisamos especificar o retorno dela.
* `this`: Para referenciar alguma coisa dentro do próprio escopo.

> `Conta contaMateus = Conta();` - Variável do tipo `Conta` chamada `contaMateus`, a qual atribuiremos a `Conta()`.

* `Conta` serviu como um **molde**.


## Criando objetos, acessando valores e guardando contas

```dart
void main() {

    Conta contaMateus = Conta("Mateus", 1000);
    Conta contaRoberta = Conta("Roberta", 2000);

    List<Conta> contas = <Conta>[contaMateus, contaRoberta];

    print(contaMateus.titular);
    print(contaMateus.saldo);

    print(contaRoberta.titular);
    print(contaRoberta.saldo);

    contaRoberta.saldo = 5000;

    print(contaRoberta.saldo);

}

class Conta {

    String titular;
    double saldo;

    Conta(this.titular, this.saldo);
    
}
```

```dart
Mateus
1000
Roberta
2000
5000
```

```dart
void main() {

    Conta contaMateus = Conta("Mateus", 1000);
    Conta contaRoberta = Conta("Roberta", 2000);

    List<Conta> contas = <Conta>[contaMateus, contaRoberta];

    for (Conta conta in contas) {
        print(conta.titular);
        print(conta.saldo);
    }

    contaRoberta.saldo = 5000;

    print(contaRoberta.saldo);
    
}

class Conta {

    String titular;
    double saldo;

    Conta(this.titular, this.saldo);

}
```
```dart
Mateus
1000
Roberta
2000
5000
```

### Alterando os valores das variáveis

**Mudar a propriedade de uma classe**: Do mesmo jeito que atribuímos um valor a uma variável, usando o sinal de igual (`=`) para atribuição. `contaRoberta.saldo = 5000;`.

Acessar e modificar as propriedades de uma classe: `nomeDaClasse.noDaVariável`. Se quisermos alterar, basta adicionarmos `=` e passar o novo valor.

Não podemos passa um **tipo de valor diferente**.

Podemos alterar os valores das variáveis, **mas não o tipo delas**.


## O que é Programação Orientada a Objetos (POO)

**Orientação a Objetos**:
    
    Forma representativa de escrever código com classes.

* **Paradigma**.
* Sigla: `POO`.
* Representar coisas do mundo real em classes.

Representação de uma **casa**.
```dart
class Casa {

    double metros;
    String cor;

}
```

### Classes:
* Servem como **moldes** ou **plantas de uma construção**.
* Contém tudo que é necessário (metragem, cor, ...).
* Como um **projeto**.
* Contém tudo o que é necessário para construir algo, mas *ainda não é o objeto em si*.
* Contém **informações e caraterísticas** do que é algo.

**Classe Conta**
```dart
class Conta {

    String titular;
    double _saldo;

}
```
A partir dela:

**Objeto contaMateus**:
```dart
Conta contaMateus = Conta("Mateus", 1000);
```

**Objeto contaRoberta**:
```dart
Conta contaRoberta = Conta("Roberta", 2000);
```

### Objeto

* É uma **variável** criada a partir de uma classe.
* Classe preenchida **com informações**.

#### **Classe**: Molde ou planta da casa.
```dart
class Casa {
    double metros;
    String cor;

    Casa(this.metros, this.cor);
}
```

#### **Objeto**: Casa construída e mobiliada.
```dart
Casa casaAzul = Casa(65, "azul");

Casa casaRosa = Casa(100, "rosa");
```

### Instanciação

* Criar a classe, criar um objeto.
* É o processo de **criar um objeto a partir de uma classe**.
* Criar uma variável **a partir do método construtor** de uma classe.

## Para saber mais: atributos nomeados em construtores no Dart

* As classes são como moldes que definem **características** *(atributos)* e **comportamentos** de um objeto.

* A **classe é a estrutura** que define esse objeto e suas características e comportamentos.
  
* *Por exemplo*: Uma class `Conta` define os atributos (`titular` e `saldo`) de um objeto conta (o objeto `contaMateus` e o objeto `contaRoberta`).


**Atributos nomeados**: Código mais limpo e fácil de entender.

```dart
class Usuario {

    String nome;
    String email;
    String senha;
    String cpf;
    bool ativo;

    Usuario(this.nome, this.email, this.senha, this.cpf, this.ativo);

}
```
Na classe `Usuario`, temos 5 atributos: `nome`, `email`, `senha`, `cpf`, `ativo` e também um construtor.

**Instanciando essa classe**:
```dart
Usuario usuarioJoao = Usuario("João da Silva", "joao@example.com", "minhaSenha123", "000.000.000-00", true);
```

* A ordem dos argumentos deve ser **precisa**.

* Os **atributos nomeados** organizam a maneira de definir os valores que cada atributo irá receber.

* Para nomear os atributos, na criação da classe, **usamos chaves para envolver todos os parâmetros** do construtor.

```dart
class Usuario {

    String nome;
    String email;
    String senha;
    String cpf;
    bool ativo;

    Usuario({this.nome, this.email, this.senha, this.cpf, this.ativo});

}
```

Agora, ao criar um novo usuário, pode passar o **nome do atributo seguido de dois pontos** e o **valor** que ele deve receber.

```dart
Usuario usuario_joao = Usuario(email: "joao@example.com", nome: "João da Silva", senha: "minhaSenha123", cpf: "000.000.000-00", ativo: true);
```

Com essa abordagem podemos passar os valores em **qualquer ordem**.
Reduzindo o risco de erros ao preencher os dados no construtor.

## Mão na massa: vendendo receitas

1. Crie uma classe `Receita`.
2. Crie 3 entradas de receitas.
3. Guarde em uma lista.

```dart
void main() {

    // 2. Crie 3 entradas de receitas.
    Receita itemUm = Receita("Macarrão ao pesto", 20.00);
    Receita itemDois = Receita("Lasanha 4 queijos", 32.00);
    Receita itemTres = Receita("Burrata com pesto", 28.00);

    // 3. Guarde em uma lista.
    List<Receita> receitas = <Receita>[itemUm, itemDois, itemTres];

}

// 1. Crie uma classe `Receita`.
class Receita {
    
    String nome;
    double preco;

    Receita(this.nome, this.preco);

}
```

## Lista de exercícios

### 01. Criando uma classe para itens de estoque. 

Você trabalha no time de desenvolvimento de um sistema de gestão de estoque para uma loja de eletrônicos. Sua tarefa é criar uma classe chamada `ItemEstoque` que deverá armazenar informações sobre o nome do produto e a quantidade em estoque. Em seguida, você deve instanciar dois itens: um para "Smartphone", com 100 unidades em estoque, e outro para "Notebook", com 50 unidades. Por fim, você deve imprimir as informações desses itens no terminal.

O print no terminal deve ser algo parecido com isto:

```dart
Produto: Smartphone, Quantidade em estoque: 100
Produto: Notebook, Quantidade em estoque: 50
```

### 01. Resposta

```dart
class ItemEstoque {

    String nomeProduto;
    int quantidade;

    ItemEstoque(this.nomeProduto, this.quantidade);

}

void main() {

    // Instanciando os itens
    ItemEstoque smartphone = ItemEstoque("Smartphone", 100);
    ItemEstoque notebook = ItemEstoque("Notebook", 50);

    // Imprimindo informações dos itens
    print('Produto: ${smartphone.nomeProduto}, Quantidade em estoque: ${smartphone.quantidade}');
    print('Produto: ${notebook.nomeProduto}, Quantidade em estoque: ${notebook.quantidade}');


    /* Alternativa para imprimir os itens
    List<ItemEstoque> itens = <ItemEstoque>[smartphone, notebook];

    for (ItemEstoque item in itens) {
        print("Produto: ${item.produto}, Quantidade em estoque: ${item.quantidadeEstoque}");
    }
    */
}
```

### 02. Implementando operações de entrada e saída de estoque.

Agora que criou a classe `ItemEstoque`, você precisa adicionar funcionalidades para registrar entradas e saídas de produtos no estoque. Implemente métodos dentro da classe `ItemEstoque` para realizar essas operações. Teste esses métodos registrando uma entrada de 20 unidades para o "Smartphone" e uma saída de 10 unidades do "Notebook". Por último, imprima as novas quantidades em estoque no terminal.

### 02. Resposta 

```dart
class ItemEstoque {

    String nomeProduto;
    int quantidade;

    ItemEstoque(this.nomeProduto, this.quantidade);

    void registrarEntrada(int valor) {
        quantidade += valor;
    }

    void registrarSaida(int valor) {
        if (quantidade >= valor) {
            quantidade -= valor;
        } else {
            print('Quantidade insuficiente em estoque para realizar a saída.');
        }
    }

}

void main() {

    // Instanciando os itens
    ItemEstoque smartphone = ItemEstoque('Smartphone', 100);
    ItemEstoque notebook = ItemEstoque('Notebook', 50);

    // Registrando entrada e saída de estoque
    smartphone.registrarEntrada(20);
    notebook.registrarSaida(10);

    // Imprimindo novas quantidades em estoque
    print('Produto: ${smartphone.nomeProduto}, Quantidade em estoque: ${smartphone.quantidade}');
    print('Produto: ${notebook.nomeProduto}, Quantidade em estoque: ${notebook.quantidade}');

}
```

### 03. Gerenciando múltiplos itens de estoque.

Você percebeu que a loja possui muitos produtos. Sua tarefa agora é fazer uma lista que armazena várias instâncias da classe `ItemEstoque`. Em seguida, implemente um laço de repetição que percorra essa lista e imprima as informações de cada item em estoque. Para testar, crie pelo menos três itens com diferentes produtos e quantidades, adicione-os à lista e exiba os detalhes de todos os itens cadastrados.

### 03. Resposta 

```dart
class ItemEstoque {

    String nomeProduto;
    int quantidade;

    ItemEstoque(this.nomeProduto, this.quantidade);

    void registrarEntrada(int valor) {
        quantidade += valor;
    }

    void registrarSaida(int valor) {
        if (quantidade >= valor) {
            quantidade -= valor;
        } else {
            print('Quantidade insuficiente em estoque para realizar a saída.');
        }
    }

}

void main() {

    // Criando a lista de itens em estoque
    List<ItemEstoque> itens = <ItemEstoque>[];

    // Adicionando itens à lista
    itens.add(ItemEstoque('Smartphone', 100));
    itens.add(ItemEstoque('Notebook', 50));
    itens.add(ItemEstoque('Tablet', 75));

    // Percorrendo a lista e imprimindo informações dos itens
    for (ItemEstoque item in itens) {
        print('Produto: ${item.nomeProduto}, Quantidade em estoque: ${item.quantidade}');
    }

}
```

### 04. Atualizando o preço dos itens.

Agora que você já tem um controle de estoque, vamos acrescentar mais uma funcionalidade ao sistema: o controle de preços dos produtos. Sua tarefa é adicionar um novo atributo `preco` à classe `ItemEstoque`. Em seguida, implemente um método que permita alterar o preço de um item específico. Crie três itens, defina seus preços iniciais e depois altere o preço de um deles. Por fim, imprima o nome do produto, sua quantidade em estoque e o preço atualizado.

### 04. Resposta 

```dart
class ItemEstoque {

    String nomeProduto;
    int quantidade;
    double preco;

    ItemEstoque(this.nomeProduto, this.quantidade, this.preco);

    void registrarEntrada(int valor) {
        quantidade += valor;
    }

    void registrarSaida(int valor) {
        if (quantidade >= valor) {
            quantidade -= valor;
        } else {
            print('Quantidade insuficiente em estoque para realizar a saída.');
        }
    }

    void atualizarPreco(double novoPreco) {
        preco = novoPreco;
    }

}

void main() {

    // Instanciando os itens
    ItemEstoque smartphone = ItemEstoque('Smartphone', 100, 2999.99);
    ItemEstoque notebook = ItemEstoque('Notebook', 50, 4999.99);
    ItemEstoque tablet = ItemEstoque('Tablet', 75, 1999.99);

    // Atualizando o preço do Notebook
    notebook.atualizarPreco(4799.99);

    // Imprimindo informações atualizadas dos itens
    print('Produto: ${smartphone.nomeProduto}, Quantidade em estoque: ${smartphone.quantidade}, Preço: R\$${smartphone.preco}');
    print('Produto: ${notebook.nomeProduto}, Quantidade em estoque: ${notebook.quantidade}, Preço: R\$${notebook.preco}');
    print('Produto: ${tablet.nomeProduto}, Quantidade em estoque: ${tablet.quantidade}, Preço: R\$${tablet.preco}');

}
```


# 02. Métodos: ações de uma conta

## Criando funções de transferência de valores

```dart
void main() {

    Conta contaMateus = Conta("Mateus", 1000);
    Conta contaRoberta = Conta("Roberta", 2000);

    List<Conta> contas = <Conta>[contaMateus, contaRoberta];

    for (Conta conta in contas) {
        print(conta.titular);
        print(conta.saldo);
    }

    contaRoberta.saldo = 5000;

    print(contaRoberta.saldo);

    receber(contaMateus, 500);

    print(contaMateus.titular);
    print(contaMateus.saldo);

    enviar(contaMateus, 200);

    print(contaMateus.titular);
    print(contaMateus.saldo);

}

void receber(Conta conta, double valor) {
    conta.saldo += valor;
}

void enviar(Conta conta, double valor) {
    conta.saldo -= valor;
}

class Conta {

    String titular;
    double saldo;

    Conta(this.titular, this.saldo);

}
```
```dart
Mateus
1000
Roberta
2000
5000
Mateus
1500
Mateus
1300
```

**Segunda tarefa**: Fazer transações (enviar e receber dinheiro)

> Ações = Funções.

Ações podem ser representadas por funções.

## Implementando métodos em uma classe Dart

```dart
class Conta {

    String titular;
    double saldo;

    Conta(this.titular, this.saldo);

    // Atrelar as funções à classe
    void receber(Conta conta, double valor) {
        conta.saldo += valor;
    }

    void enviar(Conta conta, double valor) {
        conta.saldo -= valor;
    }
}
```

Atrelar as funções à classe. Basta recortar e colar dentro da classe.

```dart
void main() {

    Conta contaMateus = Conta("Mateus", 1000);
    Conta contaRoberta = Conta("Roberta", 2000);

    List<Conta> contas = <Contas>[contaMateus, contaRoberta];

    for (Conta conta in contas) {
        print(conta.titular);
        print(conta.saldo);
    }

    contaRoberta.saldo = 5000;

    print(contaRoberta.saldo);

    contaMateus.receber(500);

    print(contaMateus.titular);
    print(contaMateus.saldo);

    contaMateus.enviar(200);

    print(contaMateus.titular);
    print(contaMateus.saldo);

}

class Conta {

    String titular;
    double saldo;

    Conta(this.titular, this.saldo);

    void receber(double valor) {
        saldo += valor;
    }

    void enviar(double valor) {
        saldo -= valor;
    }
}
```
Removemos: `Conta conta`. 

Todas as novas conta que ainda vão ser criadas, já vão possuir acesso a essas funções.

**Método**: outra forma de chamar funções dentro de classes.

## Protegendo dados sensíveis com propriedades privadas

Equipe de testes identificou que é possível alterar o valor do saldo sem passar pelas funções de `enviar()` e `receber()`.


```dart
void main() {

    Conta contaMateus = Conta("Mateus", 1000);
    Conta contaRoberta = Conta("Roberta", 2000);

    List<Conta> contas = <Conta>[contaMateus, contaRoberta];

    for (Conta conta in contas) {
        print(conta.titular);
        print(conta._saldo);
    }

    contaRoberta._saldo = 5000;

    print(contaRoberta._saldo);

    contaMateus.receber(500);

    print(contaMateus.titular);
    print(contaMateus._saldo);

    contaMateus.enviar(200);

    print(contaMateus.titular);
    print(contaMateus._saldo);

}

class Conta {

    String titular;
    double _saldo;

    Conta(this.titular, this._saldo);

    void receber(double valor) {
        _saldo += valor;
    }

    void enviar(double valor) {
        if (_saldo >= valor) {
            _saldo -= valor;
        }
    }
}
```

**Propriedades privadas**:

* Evitar acesso indesejado.
* Evitar que outras partes do código tenham acesso a elas.
* Como deixar uma variável privada: `_nomeDaVariavel`.
* É crucial que o **underline** esteja junto ao nome da variável, sem espaços.
* Variável privada tem acesso no **mesmo arquivo**. 
* Separando a classe `Conta` em outro arquivo, o acesso à variável `saldo` será restrito.

### Separando em 2 arquivos

**bin/anybank.dart**

```dart
import '../lib/conta.dart';

void main() {

    Conta contaMateus = Conta("Mateus", 1000);
    Conta contaRoberta = Conta("Roberta", 2000);

    List<Conta> contas = <Conta>[contaMateus, contaRoberta];

    for (Conta conta in contas) {
        print(conta.titular);
        print(conta._saldo);
    }

    contaRoberta._saldo = 5000;

    print(contaRoberta._saldo);

    contaMateus.receber(500);

    print(contaMateus.titular);
    print(contaMateus._saldo);

    contaMateus.enviar(200);

    print(contaMateus.titular);
    print(contaMateus._saldo);

}
```

**lib/conta.dart**

```dart
class Conta {

    String titular;
    double _saldo;

    Conta(this.titular, this._saldo);

    void receber(double valor) {
        _saldo += valor;
    }

    void enviar(double valor) {
        if (_saldo >= valor) {
            _saldo -= valor;
        }
    }
}
```
## Imprimindo extrato e acessando propriedades privadas

**bin/anybank.dart**

```dart
import '../lib/conta.dart';

void main() {

    Conta contaMateus = Conta("Mateus", 1000);
    Conta contaRoberta = Conta("Roberta", 2000);

    List<Conta> contas = <Conta>[contaMateus, contaRoberta];

    for (Conta conta in contas) {
        conta.imprimeSaldo();
    }

    contaRoberta.receber(3000);

    contaMateus.receber(500);

    contaMateus.enviar(200);

}
```

**lib/conta.dart**

```dart
class Conta {

    String titular;
    double _saldo;

    Conta(this.titular, this._saldo);

    void receber(double valor) {
        _saldo += valor;
        imprimeSaldo();
    }

    void enviar(double valor) {
        if (_saldo >= valor) {
            _saldo -= valor;
            imprimeSaldo();
        }
    }

    void imprimeSaldo() {
        print("O saldo atual de $titular, é R\$$_saldo");
    }

}
```
```dart
O saldo atual de Mateus, é R$1000
O saldo atual de Roberta, é R$2000
O saldo atual de Roberta, é R$5000
O saldo atual de Mateus, é R$1500
O saldo atual de Mateus, é R$1300
```

## Para saber mais: atributos privados

Em Dart, assim como em muitas linguagens de programação orientadas a objetos, podemos controlar o acesso aos atributos de uma classe utilizando **modificadores de acesso**.

### 01. O que são atributos privados?

* Atributos declarados como `private` são **visíveis e acessíveis apenas dentro da própria classe** em que foram definidos.
* Usar atributos privados promove o **encapsulamento**, um princípio fundamental da programação orientada a objetos. 
  * O encapsulamento **evita modificações indesejadas** de fora da própria classe, o que aumenta a segurança do código.

### 02. Por que usar atributos privados?

* **Proteção**: Ao tornar um atributo privado, você garante que ele não seja alterado acidentalmente ou de forma incorreta por outras classes ou métodos.
* **Organização**: A separação entre a lógica interna e externa de uma classe torna o código mais organizado e fácil de entender.
* **Reuso**: Atributos privados podem ser alterados internamente à classe sem afetar o código que utiliza essa classe.

```dart
class Pessoa {
  
    // Atributo privado para armazenar o nome
    String _nome;

    // Construtor para inicializar o atributo privado
    Pessoa(this._nome);

}
```

## Lista de exercícios

Você está desenvolvendo um Aplicativo de reservas de hotel em que clientes reservam quartos e gerenciam suas estadias. O sistema deve permitir que os clientes façam reservas, cancelem reservas, e consultem o status de suas reservas. Durante a implementação inicial, surgiram algumas necessidades de melhoria, como garantir a privacidade dos dados e otimizar a organização do código.

### 01. Criando uma classe de cliente

Escreva o código de uma classe que abstrai um cliente. As características (atributos) da classe são: nome do cliente e uma lista de quartos reservados. Apenas escreva a classe, sem mostrar nada no terminal com um print.

### 01. Resposta

```dart
class Cliente {
  
    String nome;
    List<String> reservas;

    Cliente(this.nome, this.reservas);

}
```

### 02. Realizando uma reserva de quarto

Implemente uma função dentro da classe `Cliente` que permita ao cliente fazer uma reserva de quarto. Essa função deve adicionar o quarto reservado à lista de reservas do cliente e, em seguida, exibir a lista atualizada de reservas. Certifique-se de que a função está corretamente encapsulada dentro da classe. Também, faça a instância da classe com um objeto, por exemplo, o cliente Joaquim.

### 02. Resposta

```dart
class Cliente {

    String nome;
    List<String> reservas;

    Cliente(this.nome, this.reservas);

    void fazerReserva(String quarto) {
        reservas.add(quarto);
        _mostrarReservas();
    }

    void _mostrarReservas() {
        print(reservas);
    }

}

void main() {

    Cliente cliente = Cliente('Joaquim', []);

    cliente.fazerReserva('101');
    cliente.fazerReserva('102');

}
```

### 03. Cancelando uma reserva

Implemente uma função dentro da classe `Cliente` que permita ao cliente cancelar uma reserva existente. A função deve remover o quarto da lista de reservas do cliente, desde que ele tenha uma reserva ativa para aquele quarto, e exibir a lista atualizada de reservas. Garanta que a função só permita o cancelamento se o cliente tiver realmente uma reserva para aquele quarto.

### 03. Resposta

```dart
class Cliente {

    String nome;
    List<String> reservas;

    Cliente(this.nome, this.reservas);

    void fazerReserva(String quarto) {
        reservas.add(quarto);
        _mostrarReservas();
    }

    void cancelarReserva(String quarto) {
        if (reservas.contains(quarto)) {
            reservas.remove(quarto);
            _mostrarReservas();
        }
    }

    void _mostrarReservas() {
        print(reservas);
    }

}

void main() {

    Cliente cliente = Cliente('Joaquim', []);
    
    cliente.fazerReserva('101');
    cliente.fazerReserva('102');
    cliente.fazerReserva('103');
    cliente.cancelarReserva('102');

}
```

### 04. Protegendo os dados das reservas

Altere o código da classe `Cliente` para que a lista de reservas seja uma propriedade privada, impedindo que ela seja alterada diretamente de fora da classe. Em vez disso, as operações de adicionar e cancelar reservas devem ser realizadas apenas por meio de métodos específicos dentro da classe. Verifique se a lista de reservas está protegida e testada corretamente.

### 04. Resposta

```dart
class Cliente {

    String nome;
    List<String> _reservas;

    Cliente(this.nome, this._reservas);

    void fazerReserva(String quarto) {
        _reservas.add(quarto);
        _mostrarReservas();
    }

    void cancelarReserva(String quarto) {
        if (_reservas.contains(quarto)) {
            _reservas.remove(quarto);
            _mostrarReservas();
        }
    }

    void _mostrarReservas() {
        print(_reservas);
    }

}

void main() {

    Cliente cliente = Cliente('Joaquim', []);

    cliente.fazerReserva('101');
    cliente.fazerReserva('102');
    cliente.fazerReserva('103');
    cliente.cancelarReserva('102');

}
```



# 03. Herança e polimorfismo

## Reaproveitando código com herança

Tarefa: criar 2 novos tipos de contas, a conta corrente e a conta poupança.

**bin/anybank.dart**

```dart
import '../lib/conta.dart';

void main() {

    Conta contaMateus = Conta("Mateus", 1000);
    Conta contaRoberta = Conta("Roberta", 2000);

    ContaCorrente contaChris = ContaCorrente("Chris", 4000);
    ContaPoupanca contaDenise = ContaPoupanca("Denise", 4000);

    /*
    List<Conta> contas = <Contas>[contaMateus, contaRoberta];

    for (Conta conta in contas) {
        conta.imprimeSaldo();
    }

    contaRoberta.receber(3000);
    contaMateus.receber(500);
    contaMateus.enviar(200);
    */

    contaChris.imprimirSaldo();
    contaChris.receber(100);
    
    contaDenise.imprimirSaldo();
    contaDenise.enviar(300);

}
```

**lib/conta.dart**

```dart
class Conta {

    String titular;
    double _saldo;

    Conta(this.titular, this._saldo);

    void receber(double valor) {
        _saldo += valor;
        imprimeSaldo();
    }

    void enviar(double valor) {
        if (_saldo >= valor) {
            _saldo -= valor;
            imprimeSaldo();
        }
    }

    void imprimeSaldo() {
        print("O saldo atual de $titular, é R\$$_saldo");
    }

}

class ContaCorrente extends Conta {
    ContaCorrente(super.titular, super._saldo);
}

class ContaPoupanca extends Conta {
    ContaPoupanca(super.titular, super._saldo);
}
```

    Quando há repetição de código, pode haver algo errado.

Para indicar que `ContaCorrente` e `ContaPoupanca` compartilham características com a classe `Conta`, usa-se a palavra-chave **`extends`**.

**`super`**: Referenciar uma propriedade de uma classe que estamos tentando implementar dentro de outra classe.

```dart
class ContaCorrente extends Conta {
    ContaCorrente(super.titular, super._saldo);
}

class ContaPoupanca extends Conta {
    ContaPoupanca(super.titular, super._saldo);
}
```

* **Todas as propriedades e métodos** da classe `Conta` foram acessadas nas classes `ContaCorrente` e `ContaPopupanca`.

* `extends Conta`: Processo de **herança**.
  * Permite que uma classe **herde propriedades, atributos e métodos** de outra classe.

## Para saber mais: outras formas de chamar superclasse

2 formas comuns para instanciar atributos da superclasse em subclasses.

```dart
class Animal {

    String nome;

    Animal(this.nome);

    void comer() {
        print('$nome está comendo.');
    }

}

class Cachorro extends Animal {

    String cor;

    Cachorro(this.cor);

    void latir() {
        print('$nome está latindo.');
    }

}
```

### 1ª forma:

```dart
class Cachorro extends Animal {

    String cor;

    Cachorro(this.cor, super.nome);
    
    void latir() {
        print('$nome está latindo.');
    }

}
```

### 2ª forma: 

```dart
class Cachorro extends Animal {

    String cor;

    Cachorro(this.cor, String nome): super(nome);

    void latir() {
        print('$nome está latindo.');
    }

}
```

## Diferenciando classes com polimorfismo

**bin/anybank.dart**

```dart
import '../lib/conta.dart';

void main() {

    Conta contaMateus = Conta("Mateus", 1000);
    Conta contaRoberta = Conta("Roberta", 2000);

    ContaCorrente contaChris = ContaCorrente("Chris", 4000);
    ContaPoupanca contaDenise = ContaPoupanca("Denise", 4000);

    contaChris.imprimirSaldo();
    contaChris.enviar(4300);
    
    contaDenise.imprimirSaldo();
    contaDenise.enviar(4300);
    contaDenise.calculaRendimento();
    contaDenise.imprimirSaldo();

}
```

**lib/conta.dart**

```dart
class Conta {

    String titular;
    double _saldo;

    Conta(this.titular, this._saldo);

    void receber(double valor) {
        _saldo += valor;
        imprimeSaldo();
    }

    void enviar(double valor) {
        if (_saldo >= valor) {
            _saldo -= valor;
            imprimeSaldo();
        }
    }

    void imprimeSaldo() {
        print("O saldo atual de $titular, é R\$$_saldo");
    }

}

class ContaCorrente extends Conta {

    double emprestimo = 300;

    ContaCorrente(super.titular, super._saldo);

    @override
    void enviar(double valor) {
        if (_saldo + emprestimo >= valor) {
            _saldo -= valor;
            imprimeSaldo();
        }
    }
}

class ContaPoupanca extends Conta {

    double rendimento = 0.05;

    ContaPoupanca(super.titular, super._saldo);

    void calculaRendimento() {
        _saldo += _saldo * rendimento;
    }
}
```

**Herança**: É a capacidade de uma classe transmitir seus atributos e métodos para outra classe.

No caso em questão, `ContaCorrente()` e `ContaPoupanca()` herdam as propriedades `titular` e `saldo`, além dos métodos de `enviar()`, `receber()` e `imprimeSaldo()` da classe `Conta`.

Sobrescrita do método `enviar()`: 

```dart
@override
void enviar() {}
```

## Mão na massa: a equipe do bistrô

O bistrô está contratando novos funcionários e você precisa criar um sistema para gerenciar a equipe. Existem três tipos de funcionários: cozinheiros, garçons e gerentes. Cada funcionário possui um nome e um salário.

```dart
class Funcionario {
    String nome;
    double salario;

    Funcionario(this.nome, this.salario);
}

class Cozinheiro extends Funcionario {
    // ...
}

class Garcom extends Funcionario {
    // ...
}

class Gerente extends Funcionario {
    // ...
}
```

Você precisa criar um método trabalhar que imprima uma mensagem diferente para cada tipo de funcionário, indicando o que ele faz.

```dart
class Funcionario {

    String nome;
    double salario;

    Funcionario(this.nome, this.salario);

    void trabalhar() {
        print("$nome trabalhou");
    }

}

class Cozinheiro extends Funcionario {

    Cozinheiro(super.nome, super.salario);

    @override
    void trabalhar() {
        print("$nome trabalhou na cozinha");
    }

}

class Garcom extends Funcionario {

    Garcom(super.nome, super.salario);

    @override
    void trabalhar() {
        print("$nome trabalhou no atendimento");
    }

}

class Gerente extends Funcionario {

    Gerente(super.nome, super.salario);

    @override
    void trabalhar() {
        print("$nome gerenciou a equipe");
    }

}
```

## Aprofundando em herança e polimorfismo

### Herança e polimorfismo

- **Herança**: É a capacidade de uma coisa **herdar características de outra**.
  - *Exemplo*: herdar características dos pais.

- **Polimorfismo**: É a capacidade de uma classe ou objeto de **ter diferentes formas**.
  - *Exemplo* de um animal: pássaro voa a cobra rasteja.
  
#### Palavras reservadas: 
- **`extends`**: Usamos para especificar a classe da qual queremos herdar propriedades e métodos.
- **`super`**: Fazer referência aos atributos da classe que estamos herdando (classe pai).
  - `this`: Referencia os atributos da classe atual. 
- **`@override`**: Uma notação está sendo sobrescrita.

**Classe Animal**

```dart
class Animal {

    String nomeCientifico;
    int idade;

    void locomover() {
        print("Estou me locomovendo");
    }

}

class Passaro extends Animal {

    Passaro(super.nomeCientifico, super.idade);

    @override
    void locomover() {
        print("Estou voando!");
    }

}

class Cobra extends Animal {

    Cobra(super.nomeCientifico, super.idade);

    @override
    void locomover() {
        print("Estou rastejando!");
    }

    void trocarDePele(){}

}
```

## Para saber mais: mais exemplos de herança e polimorfismo

### 1. O que é herança?

**Herança** é uma forma de criar novas classes (**subclasses ou filhas**) a partir de classes já existentes (**superclasses ou mães**). Essa nova classe herda todos os atributos e métodos da classe mãe (ou superclasse), podendo adicionar novos ou sobrescrever os existentes.

### 2. Por que usar herança?

* **Evitamos a reescrita** de código comum a diferentes classes.
* Criamos uma estrutura de hierarquia entre as classes, o que **organiza o código**.

### Exemplo de "animais":

```dart
class Animal {

    String nome;

    Animal(this.nome);

    void comer() {
        print('$nome está comendo.');
    }

}

class Cachorro extends Animal {

    Cachorro(super.nome);

    void latir() {
        print('$nome está latindo.');
    }

}

class Gato extends Animal {

    Gato(super.nome);

    void miar() {
        print('$nome está miando.');
    }

}
```

* Classe **`Animal`**:
  * É a classe base (superclasse).
  * Possui um atributo `nome` e um método `comer()`.

* Classe **`Cachorro`**:
  * **Herda** o atributo (`nome`) e o método (`comer()`) da classe `Animal`.
  * Possui um método específico `latir()`.

* Classe **`Gato`**:
  * **Herda** o atributos e o método da classe `Animal`;
  * Possui um método específico `miar()`.

* As duas classes precisam inicializar dentro de seus construtores os atributos da superclasse:
  * Classe `Cachorro` usa `Cachorro(super.nome)`;
  * Classe `Gato` usa `Gato(super.nome)`.

### Como instanciar:

```dart
void main() {

    Cachorro cachorro = Cachorro('Rex');
    cachorro.comer(); // Imprime: Rex está comendo.
    cachorro.latir(); // Imprime: Rex está latindo.

    Gato gato = Gato('Mia');
    gato.comer(); // Imprime: Mia está comendo.
    gato.miar(); // Imprime: Mia está miando.

}
```

## Lista de exercícios

### 01. Criando classes de gatos e cachorros

Crie uma classe `Animal` com um método `emitirSom()`. Em seguida, crie duas outras classes: `Cachorro` e `Gato`, que herdam o método da classe `Animal`. Ao adicionar o método `emitirSom()` nas classes `Cachorro` e `Gato`, utilize a anotação `@override` para indicar que estão sobrescrevendo o método — o método `emitirSom` deve fazer um print "O cachorro late" para `Cachorro` e "o gato miou" para `Gato`.

Além disso, adicione métodos específicos para cada classe, como `abanarRabo()` para o `Cachorro` e `arranharMoveis()` para o `Gato`.

O print no terminal deve ser semelhante a isto:
```dart
O cachorro late.
O cachorro está abanando o rabo. 
O gato miou.
O gato está arranhando os móveis.
```

### 01. Resposta
```dart
// Classe base Animal
class Animal {

    void emitirSom() {
        print("O animal emitiu um som.");
    }

}

// Classe Cachorro que herda de Animal
class Cachorro extends Animal {

    @override
    void emitirSom() {
        print("O cachorro late.");
    }

    void abanarRabo() {
        print("O cachorro está abanando o rabo.");
    }

}

// Classe Gato que herda de Animal
class Gato extends Animal {

    @override
    void emitirSom() {
        print("O gato miou.");
    }

    void arranharMoveis() {
        print("O gato está arranhando os móveis.");
    }

}

void main() {

    // Instanciando as classes e chamando os métodos
    Cachorro cachorro = Cachorro();
    Gato gato = Gato();

    cachorro.emitirSom(); // O cachorro late.
    cachorro.abanarRabo(); // O cachorro está abanando o rabo.

    gato.emitirSom(); // O gato miou.
    gato.arranharMoveis(); // O gato está arranhando os móveis.

}
```


### 02. Produzindo uma conta salário com herança

Continuando o projeto Any Bank, é hora de criar um terceiro tipo de conta: a **conta salário**. Assim como as classes conta corrente e conta poupança, ela possui duas características essenciais: o `titular` e o `saldo`.

Escreva o código da classe `ContaSalario` e um objeto de conta salário de uma pessoa chamada Catarina (ou qualquer nome que você desejar). Se quiser, imprima o saldo da pessoa no terminal.

Dicas:

Crie o código da classe `ContaSalario` e faça a instanciação do objeto `contaSalarioCatarina`;
Empregue a técnica de **herança** para evitar a repetição de código;
Apenas declare a classe. Não é preciso fazer nada além disso.

### 02. Resposta
```dart
class ContaSalario extends Conta {
    ContaSalario(super.titular, super._saldo);
}
```

### 03. Incrementando a conta salário com polimorfismo

Agora, vamos melhorar a classe da conta salário. Você deve saber que a `contaSalario` tem duas características em comum com as contas corrente e poupança: `titular` e `saldo`. No entanto, ela apresenta três características **diferentes**:

* Variável com o CNPJ da empresa que emprega o(a) titular da conta;
* Variável do nome da empresa;
* Um método (função `print`) que diz algo como: "O salário da \$empresa, de CNPJ X no valor de R\$xx.x, foi depositado!"
Aplique essas três características na classe contaSalario!

Dica:

* Aplique a técnica de **polimorfismo** para diferenciar a conta salário das contas corrente e poupança.

### 03. Resposta
```dart
class ContaSalario extends Conta {
    String cnpjEmpresa;
    String nomeEmpresa;

    ContaSalario(super.titular, super._saldo, this.cnpjEmpresa, this.nomeEmpresa);

    void depositarSalario(double valor) {
        _saldo += valor;
        print("O salário da $nomeEmpresa, de CNPJ $cnpjEmpresa no valor de R\$$valor foi depositado!");
    }

}

void main() {
    ContaSalario contaSalarioCatarina = ContaSalario("Catarina", 5000, "123456789", "AnyBank");
    contaSalarioCatarina.depositarSalario(1000);
    contaSalarioCatarina.imprimeSaldo();
}
```


### 04. Representando quartos com herança

Crie três classes que representam três tipos de quartos em um hotel: quarto simples, quarto médio e quarto luxo. Todos os quartos têm em comum as seguintes características:

* **Tipo de quarto**: indica se o quarto é simples, médio ou luxo;
* **Valor da diária**: registra a diária do tipo do quarto. Por exemplo, a diária do quarto simples é 80 reais; a do quarto médio é 250 reais; a do quarto luxo é 1000 reais. Repare que todos possuem a característica valorDiaria em comum, que é reaproveitada nos três tipos de quarto;
* **Número de diárias**: o número de diárias reservadas por um(a) hóspede;
* **Método de reservar**: realiza a ação de reservar um quarto.

### 04. Resposta
```dart
void main() {

    QuartoSimples quartoSimples = QuartoSimples(3);
    quartoSimples.reservar();
    QuartoMedio quartoMedio = QuartoMedio(5);
    quartoMedio.reservar();
    QuartoLuxo quartoLuxo = QuartoLuxo(7);
    quartoLuxo.reservar();

}

class Quarto {

    String tipo;
    double valorDiaria;
    int diarias;

    Quarto(this.diarias, this.valorDiaria, this.tipo);

    void reservar() {
        print("Reserva realizada para $diarias diarias no quarto $tipo.");
    }

}

class QuartoSimples extends Quarto {

    QuartoSimples(int diarias) : super(diarias, 80, 'Simples');

}

class QuartoMedio extends Quarto {

    QuartoMedio(int diarias) : super(diarias, 250, 'Médio');

}

class QuartoLuxo extends Quarto {

    QuartoLuxo(int diarias) : super(diarias, 1000, 'Luxo');

}
```

### 05. Adicionando diferenças com polimorfismo

Agora que você criou as três classes de quartos, adicione as diferenças que existem entre elas:

* **Café da manhã**: apenas os quartos médio e luxo possuem esta comodidade. Implemente essa característica com método que contém um print como "Servindo café da manhã no quarto do $tipo";
* **Serviço de quarto**: exclusivo do quarto luxo. Crie um método print do serviço de quarto, como "Limpando o quarto $tipo."

### 05. Resposta
```dart
void main() {

    QuartoSimples quartoSimples = QuartoSimples(3);
    quartoSimples.reservar();
    QuartoMedio quartoMedio = QuartoMedio(5);
    quartoMedio.reservar();
    quartoMedio.servirCafeDaManha();
    QuartoLuxo quartoLuxo = QuartoLuxo(7);
    quartoLuxo.reservar();
    quartoLuxo.servirCafeDaManha();
    quartoLuxo.servicoDeQuarto();

}

class Quarto {

    String tipo;
    double valorDiaria;
    int diarias;

    Quarto(this.diarias, this.valorDiaria, this.tipo);

    void reservar() {
        print("Reserva realizada para $diarias diarias no quarto $tipo.");
    }

}

class QuartoSimples extends Quarto {

    QuartoSimples(int diarias) : super(diarias, 80, 'Simples');

}

class QuartoMedio extends Quarto {

    QuartoMedio(int diarias) : super(diarias, 250, 'Médio');

    void servirCafeDaManha() {
        print("Servindo cafe da manha no quarto $tipo.");
    }

}

class QuartoLuxo extends Quarto {

    QuartoLuxo(int diarias) : super(diarias, 1000, 'Luxo');

    void servirCafeDaManha() {
        print("Servindo cafe da manha no quarto $tipo.");
    }

    void servicoDeQuarto() {
        print("Limpando o quarto $tipo.");
    }

}
```

### 06. Criando um método de cálculo de diárias

Agora, cada tipo de quarto deve calcular o valor total da reserva com base em tarifas específicas. Você precisa ajustar as classes para lidar com essas tarifas.

Adicione um método `calcularValorTotal` nas classes `Quarto`, `QuartoMedio` e `QuartoLuxo`. O método deve calcular o valor total da reserva com base em uma tarifa diária específica para cada tipo de quarto. Na main, crie exemplos de reservas para os três tipos de quarto e mostre o valor total calculado.

### 06. Resposta
```dart
void main() {

    QuartoSimples quartoSimples = QuartoSimples(3);
    quartoSimples.reservar();
    quartoSimples.calcularValorTotal();
    QuartoMedio quartoMedio = QuartoMedio(5);
    quartoMedio.reservar();
    quartoMedio.servirCafeDaManha();
    quartoMedio.calcularValorTotal();
    QuartoLuxo quartoLuxo = QuartoLuxo(7);
    quartoLuxo.reservar();
    quartoLuxo.servirCafeDaManha();
    quartoLuxo.servicoDeQuarto();
    quartoLuxo.calcularValorTotal();

}

class Quarto {

    String tipo;
    double valorDiaria;
    int diarias;

    Quarto(this.diarias, this.valorDiaria, this.tipo);

    void reservar() {
        print("Reserva realizada para $diarias diarias no quarto $tipo.");
    }

    void calcularValorTotal() {
        print("Total a pagar: R\$${diarias * valorDiaria}");
    }
    
}

class QuartoSimples extends Quarto {
    
    QuartoSimples(int diarias) : super(diarias, 80, 'Simples');

}

class QuartoMedio extends Quarto {

    QuartoMedio(int diarias) : super(diarias, 250, 'Médio');

    void servirCafeDaManha() {
        print("Servindo cafe da manha no quarto $tipo.");
    }

}

class QuartoLuxo extends Quarto {
    
    QuartoLuxo(int diarias) : super(diarias, 1000, 'Luxo');

    void servirCafeDaManha() {
        print("Servindo cafe da manha no quarto $tipo.");
    }

    void servicoDeQuarto() {
        print("Limpando quarto $tipo.");
    }

}
```

### 07. Implementando uma classe de ingrediente

Considere que você precisa criar um programa que registra ingredientes de receitas e informações sobre eles. O primeiro passo é implementar a classe `Ingrediente`, que terá as seguintes características (atributos) e ações (métodos):

* `string nome`: armazena o nome de um ingrediente (por exemplo, cebola);
* `string tipo`: armazena o tipo de ingrediente (por exemplo, fruta, legume ou tempero).
* Método `detalhes()`: printa o nome e o tipo do ingrediente.

A ideia é apenas criar a classe. Não se preocupe em printar nada no terminal por enquanto!

### 07. Resposta
```dart
// Classe base Ingrediente
class Ingrediente {
    
    String nome;
    String tipo;

    Ingrediente(this.nome, this.tipo);

    void detalhes() {
        print('Ingrediente: $nome');
        print('Tipo: $tipo');
    }

}
```

### 8. Implementando as classes de tipos de ingrediente

Vamos continuar o programa de receitas. Agora que você concluiu a classe abstrata `Ingrediente`, vamos usá-la de molde para criar três classes de tipos de ingrediente:

* `Fruta`: em geral, são vegetais que não podem ser cozidos nas receitas;
* `Legume`: em geral, são vegetais que precisam ser cozidos;
* `Tempero`: são especiarias que condimentam os alimentos.

Ao criar as três classes, aplique a herança e polimorfismo. Sobrescreva o método `detalhes()` em cada uma das classes. Por exemplo, em `Fruta`, você pode inserir um print “em geral, são vegetais que não podem ser cozidos nas receitas” e assim por diante.

Por fim, crie os objetos `banana` (de Fruta), `cenoura` (de Legume) e `sal` (de Tempero) e os métodos para exibir suas informações e detalhes. O print no terminal pode ser algo assim:
```dart
Ingrediente: Banana
Tipo: Fruta
Detalhe: As frutas geralmente não são cozidas nas receitas.      

Ingrediente: Cenoura
Tipo: Legume
Detalhe: Os legumes geralmente precisam ser cozidos nas receitas.

Ingrediente: Sal
Tipo: Tempero
Detalhe: Os temperos são usados para condimentar os alimentos.
```

### 08. Resposta
```dart
// Classe base Ingrediente
class Ingrediente {
    
    String nome;
    String tipo;

    Ingrediente(this.nome, this.tipo);

    void detalhes() {
        print('Ingrediente: $nome');
        print('Tipo: $tipo');
    }

}

// Classe Fruta, que herda de Ingrediente
class Fruta extends Ingrediente {
    
    Fruta(String nome) : super(nome, 'Fruta');

    @override
    void detalhes() {
        print('Detalhe: As frutas geralmente não são cozidas nas receitas.');
    }

}

// Classe Legume, que herda de Ingrediente
class Legume extends Ingrediente {
    
    Legume(String nome) : super(nome, 'Legume');

    @override
    void detalhes() {
        print('Detalhe: Os legumes geralmente precisam ser cozidos nas receitas.');
    }

}

// Classe Tempero, que herda de Ingrediente
class Tempero extends Ingrediente {
    
    Tempero(String nome) : super(nome, 'Tempero');

    @override
    void detalhes() {
        print('Detalhe: Os temperos são usados para condimentar os alimentos.');
    }

}

void main() {
    
    // Criando instâncias de frutas, legumes e temperos
    var banana = Fruta('Banana');
    var cenoura = Legume('Cenoura');
    var sal = Tempero('Sal');

    // Exibindo os detalhes
    banana.detalhes();
    print('');
    cenoura.detalhes();
    print('');
    sal.detalhes();
    
}
```



# 04. Classe abstrata

## Produzindo um molde com classe abstrata

**bin/anybank.dart**

```dart
import '../lib/conta.dart';

void main() {

    ContaCorrente contaChris = ContaCorrente("Chris", 4000);
    ContaPoupanca contaDenise = ContaPoupanca("Denise", 4000);

    contaChris.imprimeSaldo();
    contaChris.enviar(4300);
    
    contaDenise.imprimeSaldo();
    contaDenise.enviar(4300);
    contaDenise.calculaRendimento();
    contaDenise.imprimeSaldo();

}
```

**lib/conta.dart**

```dart
abstract class Conta {

    String titular;
    double _saldo;

    Conta(this.titular, this._saldo);

    void receber(double valor) {
        _saldo += valor;
        imprimeSaldo();
    }

    void enviar(double valor) {
        if (_saldo >= valor) {
            _saldo -= valor;
            imprimeSaldo();
        }
    }

    void imprimeSaldo() {
        print("O saldo atual de $titular, é R\$$_saldo");
    }

}

class ContaCorrente extends Conta {

    double emprestimo = 300;

    ContaCorrente(super.titular, super._saldo);

    @override
    void enviar(double valor) {
        if (_saldo + emprestimo >= valor) {
            _saldo -= valor;
            imprimeSaldo();
        }
    }
}

class ContaPoupanca extends Conta {

    double rendimento = 0.05;

    ContaPoupanca(super.titular, super._saldo);

    void calculaRendimento() {
        _saldo += _saldo * rendimento;
    }
}
```
```dart
O saldo atual de Chris, é R$4000
O saldo atual de Chris, é R$-300
O saldo atual de Denise, é R$4000
O saldo atual de Denise, é R$4200
```

### Classes abstratas

* **Não podem ser instanciadas**.
* **Servem apenas como base** para outras classes implementarem propriedades e funcionalidades.

```dart
abstract class Conta {

    String titular;
    double _saldo;
    ...

}
```

## Para saber mais: mais sobre classes abstratas

* Podemos pensar em uma **classe abstrata** como um **esqueleto** de uma classe.
* Servem como **modelos para outras classes**, definindo uma estrutura em comum. 
* São úteis para **criar hierarquias de classes** e garantir que as subclasses implementem determinadas funcionalidades.
* Ele define uma estrutura básica **como um guia**, com propriedades e métodos, mas não pode ser instanciada diretamente.
* Métodos abstratos são declarados com a palavra-chave `abstract`.
* **Subclasses devem implementar todos os métodos abstratos** da superclasse.
* Uma classes abstrata pode ter métodos com implementações próprias que podem ser sobrescritas em outras classes (embora não seja o uso mais indicado).
    

        Você não pode criar um objeto a partir de uma classe abstrata.

### Por que usar classes abstratas?

* Definimos um **"contrato"** que as subclasses devem seguir, garantindo que **todas as classes que herdam dela tenham as mesmas funcionalidades e propriedades**.
* Incentivamos também o **polimorfismo** permitindo que objetos de diferentes classes sejam tratados como se fossem de uma classes abstrata mãe.

### Exemplo:
```dart
abstract class Figura {

    double calcularArea();

}

class Circulo extends Figura {

    double raio;

    Circulo(this.raio);

    @override
    double calcularArea() {
        return 3.14159 * raio * raio;
    }

}

class Quadrado extends Figura {

    double lado;

    Quadrado(this.lado);

    @override
    double calcularArea() {
        return lado * lado;
    }

}
```
```dart
void main() {

    Circulo circulo = Circulo(5);
    Quadrado quadrado = Quadrado(4);

    print('Área do círculo: ${circulo.calcularArea()}');
    print('Área do quadrado: ${quadrado.calcularArea()}');

}
```
```dart
Área do círculo: 78.53975
Área do quadrado: 16
```

## Aprofundando classes abstratas e entendendo interface no Dart

### O que é classe abstrata em POO?

* **Classe** que não é instanciada.
* **Planta de construção** para outras classes.
* **Referência** para que outros objetos existam.
* **Não forma nada** por si só.

### Interface

* **Também** não pode ser instanciada.
* **Guia de métodos** a ser implementados.

**`extends`**: Herança.
**`implements`**: Interface.

```dart
abstract class Pontuacao {

    void calculaPontos();
    void devolveColocacao();

}

class Volei extends Esporte implements Pontuacao {

    Volei(super.time);

    @override
    void calculaPontos() {
        ...
    }
    
    @override
    void devolveColocacao() {
        ...
    }

}

abstract class Esporte {

    String time;

    Esporte(this.time);

}
```

## Para saber mais: mais sobre classe abstrata e interface 

### 01. O que é classe abstrata?

* Uma classe que não pode ser instanciada, ou seja, você **não pode criar um objeto a partir de uma classe abstrata**.
* Você pode utilizar uma classe abstrata reaproveitando-a dentro de outras classes comuns (com herança e polimorfismo).
* Classes abstrata funciona como um molde para que outras classes comuns reaproveitem os atributos e métodos da classe abstrata.

### 02. O que é interface?

* **Define padrões** que uma classe deve cumprir.
* Ela especifica **quais métodos e propriedades que uma classe deve ter**, sem se preocupar com a implementação.

#### Por que usar interfaces?

* **Polimorfismo**: Cada classe que usa uma interface precisa implementar da sua própria maneira os métodos da interface.
* **Desacoplamento**: A interface aumenta o desacoplamento entre as classes (separação de responsabilidades), o que deixa o código mais flexível e fácil de manter. 

#### Exemplo:

```dart
abstract class Figura {

    double calcularArea();

}

class Circulo implements Figura {

    double raio;

    Circulo(this.raio);

    @override
    double calcularArea() {
        return 3.14159 * raio * raio;
    }

}

class Quadrado implements Figura {

    double lado;

    Quadrado(this.lado);

    @override
    double calcularArea() {
        return lado * lado;
    }

}
```
```dart
void main() {

    List<Figura> figuras = [Circulo(5), Quadrado(4)];

    for (var figura in figuras) {
        print('Área: ${figura.calcularArea()}');
    }

}
```
```dart
Área: 78.53975
Área: 16
```

#### Importante:

* **Uma classe pode implementar várias interfaces**.
* Os métodos em uma interface são implicitamente abstratos (não precisam ser implementados na sua declaração).
* Uma classe pode herdar (`extends`) outra classe e implementar (`implements`) uma interface.
* Por mais que sejam parecidas com classes abstratas, interfaces não podem ter implementações de seus métodos, eles precisam acontecer na classe que faz o `implements`.

## Lista de exercícios

### 01. Refatorando o código das classes gato e cachorro

Considerando o exercício anterior, “Criando classes de gato e cachorro” em que foi solicitada a criação das classes `Animal`, `Gato` e `Cachorro` (e o método `emitirSom()`), refatore a classe `Animal`, transformando-a em uma classe abstrata.

    Lembre-se de que reescrever e refatorar código é uma atividade comum no dia a dia de uma pessoa desenvolvedora. Logo, é importante que você pratique essa atividade.

### 01. Resposta
```dart
// Classe base Animal
abstract class Animal {

    void emitirSom() {
        print("O animal emitiu um som.");
    }

}

// Classe Cachorro que herda de Animal
class Cachorro extends Animal {

    @override
    void emitirSom() {
        print("O cachorro late.");
    }

    void abanarRabo() {
        print("O cachorro está abanando o rabo.");
    }

}

// Classe Gato que herda de Animal
class Gato extends Animal {

    @override
    void emitirSom() {
        print("O gato miou.");
    }

    void arranharMoveis() {
        print("O gato está arranhando os móveis.");
    }

}

void main() {

    // Instanciando as classes e chamando os métodos
    Cachorro cachorro = Cachorro();
    Gato gato = Gato();

    cachorro.emitirSom(); // O cachorro late.
    cachorro.abanarRabo(); // O cachorro está abanando o rabo.

    gato.emitirSom(); // O gato miou.
    gato.arranharMoveis(); // O gato está arranhando os móveis.

}
```

### 02. Refatorando o código das reservas em hotel

Se você fez os exercícios da aula passada referentes às classes `quartoSimples`, `quartoMedio` e `quartoLuxo`, refatore o código que você escreveu, agora adicionando uma classe abstrata `quarto` da qual as demais classes herdam características e aplicam o polimorfismo.

Refatore o código e reflita o porquê utilizamos uma classe abstrata nesse caso.

### 02. Resposta
```dart
void main() {

    QuartoSimples quartoSimples = QuartoSimples(3);
    quartoSimples.reservar();
    quartoSimples.calcularValorTotal();
    QuartoMedio quartoMedio = QuartoMedio(5);
    quartoMedio.reservar();
    quartoMedio.servirCafeDaManha();
    quartoMedio.calcularValorTotal();
    QuartoLuxo quartoLuxo = QuartoLuxo(7);
    quartoLuxo.reservar();
    quartoLuxo.servirCafeDaManha();
    quartoLuxo.servicoDeQuarto();
    quartoLuxo.calcularValorTotal();

}

abstract class Quarto {

    String tipo;
    double valorDiaria;
    int diarias;

    Quarto(this.diarias, this.valorDiaria, this.tipo);

    void reservar() {
        print("Reserva realizada para $diarias diarias no quarto $tipo.");
    }

    void calcularValorTotal() {
        print("Total a pagar: R\$${diarias * valorDiaria}");
    }

}

class QuartoSimples extends Quarto {

    QuartoSimples(int diarias) : super(diarias, 80, 'Simples');

}

class QuartoMedio extends Quarto {

    QuartoMedio(int diarias) : super(diarias, 250, 'Médio');

    void servirCafeDaManha() {
        print("Servindo cafe da manha no quarto $tipo.");
    }

}

class QuartoLuxo extends Quarto {

    QuartoLuxo(int diarias) : super(diarias, 1000, 'Luxo');

    void servirCafeDaManha() {
        print("Servindo cafe da manha no quarto $tipo.");
    }

    void servicoDeQuarto() {
        print("Limpando quarto $tipo.");
    }

}
```

### 03. Refatorando o código dos ingredientes

É importante que você tenha feito o exercício de ingredientes e receitas da aula anterior.

Refatore o código do exercício, agora transformando a classe `ingrediente` em uma classe abstrata, fazendo as modificações necessárias e mantendo os padrões de herança e polimorfismo aplicados ao código.

### 03. Resposta
```dart
// Classe base Ingrediente
abstract class Ingrediente {

    String nome;
    String tipo;

    Ingrediente(this.nome, this.tipo);

    void detalhes() {
        print('Ingrediente: $nome');
        print('Tipo: $tipo');
    }

}

// Classe Fruta, que herda de Ingrediente
class Fruta extends Ingrediente {

    Fruta(String nome) : super(nome, 'Fruta');

    @override
    void detalhes() {
        print('Detalhe: As frutas geralmente não são cozidas nas receitas.');
    }

}

// Classe Legume, que herda de Ingrediente
class Legume extends Ingrediente {

    Legume(String nome) : super(nome, 'Legume');

    @override
    void detalhes() {
        print('Detalhe: Os legumes geralmente precisam ser cozidos nas receitas.');
    }

}

// Classe Tempero, que herda de Ingrediente
class Tempero extends Ingrediente {

    Tempero(String nome) : super(nome, 'Tempero');

    @override
    void detalhes() {
        print('Detalhe: Os temperos são usados para condimentar os alimentos.');
    }

}

void main() {

    // Criando instâncias de frutas, legumes e temperos
    var banana = Fruta('Banana');
    var cenoura = Legume('Cenoura');
    var sal = Tempero('Sal');

    // Exibindo os detalhes
    banana.detalhes();
    print('');
    cenoura.detalhes();
    print('');
    sal.detalhes();

}
```

### 04. Corrigindo um código com bugs

O código a seguir deveria imprimir no terminal que um documento do tipo relatório foi impresso. No entanto, por algum motivo, o código não funciona. Analise-o com atenção:

```dart
abstract class Documento {
    
    String nomeDoDocumento;

    Documento(this.nomeDoDocumento);

    void imprimir() {
        print('O ${relatorio.nomeDoDocumento} foi enviado para impressão');
    }

}

void main() {

    Documento relatorio = Documento('Relatório Anual');
    relatorio.imprimir();

}
```

Identifique os erros e corrija o código, considerando o que aprendemos sobre classe abstrata em Dart. Atenção: a classe abstrata `Documento` deve permanecer uma classe abstrata, pois deve funcionar como molde para outros documentos como "relatório", "planilha" etc. Pense em formas de solucionar esse problema sem transformar a classe abstrata em uma classe comum.

### 04. Resposta
```dart
// Código corrigido
abstract class Documento {
    
    String nomeDoDocumento;
    
    Documento(this.nomeDoDocumento);

    void imprimir();

}

class Relatorio extends Documento {
    
    Relatorio(String nomeDoDocumento) : super(nomeDoDocumento);
    
    @override
    void imprimir() {
        print('O $nomeDoDocumento foi enviado para impressão');
    }

}

void main() {
   
    Documento relatorio = Relatorio('Relatório Anual'); // Correção: Instanciando a classe concreta
    relatorio.imprimir();

}
```

### 05. Criando um programa de registro de funcionários

Primeiro, crie uma classe abstrata `funcionario` com os atributos nome de funcionário(a) e um double “salário base” inicializado em 3000 reais, e também um método `calcularSalario`. Em seguida, implemente, a partir de `funcionario`, as classes `analista`, `gerente` e `diretor`; sobrescreva o método `calcularSalario` nelas com os seguintes valores:

* `Analista`: salário base = salário base + salário base multiplicado por 1.2;
* `Gerente`: salário base = salário base + salário base multiplicado por 1.5;
* `Diretor`: salário base = salário base + salário base multiplicado por 2.0.

Por fim, imprima o cálculo de salário dos funcionários João (analista), Maria (gerente) e Giovana (diretora), conforme o exemplo a seguir:

```dart
Salário do Analista João: R$ 6600.0
Salário da Gerente Maria: R$ 7500.0   
Salário da Diretora Giovana: R$ 9000.0
```

### 05. Resposta

```dart
// Classe abstrata Funcionario
abstract class Funcionario {
    
    String nome;
    double salarioBase;

    Funcionario(this.nome) : salarioBase = 3000.0; // Salário base inicializado em 3000 reais

    // Método abstrato para ser implementado nas subclasses
    double calcularSalario();

}

// Classe Analista que herda de Funcionario
class Analista extends Funcionario {

    Analista(String nome) : super(nome);

    @override
    double calcularSalario() {
        return salarioBase + (salarioBase * 1.2);
    }

}

// Classe Gerente que herda de Funcionario
class Gerente extends Funcionario {

    Gerente(String nome) : super(nome);

    @override
    double calcularSalario() {
        return salarioBase + (salarioBase * 1.5);
    }

}

// Classe Diretor que herda de Funcionario
class Diretor extends Funcionario {

    Diretor(String nome) : super(nome);

    @override
    double calcularSalario() {
        return salarioBase + (salarioBase * 2.0);
    }

}

void main() {

    // Instâncias das classes para os funcionários
    Funcionario joao = Analista('João');
    Funcionario maria = Gerente('Maria');
    Funcionario giovana = Diretor('Giovana');

    // Impressão dos cálculos de salário
    print('Salário do Analista João: R\$ ${joao.calcularSalario()}');
    print('Salário da Gerente Maria: R\$ ${maria.calcularSalario()}');
    print('Salário da Diretora Giovana: R\$ ${giovana.calcularSalario()}');

}
```

### 06. Criando um programa informativo de espécies de seres vivos

Este exercício será um pouco mais desafiador.

* Crie um programa que mostra características sobre os seres vivos e implemente três classes, seguindo os requisitos de cada uma:
* Classe `SerVivo`: será uma classe abstrata que terá um método `void mostrarCaracteristicas()`;.
* **Planta**: será uma classe que implementa `SerVivo` e terá os seguintes objetos e suas descrições de print:
  * Girassol: é uma planta, não tem os cinco sentidos, é uma flor;
  * Laranjeira: é uma planta, não tem os cinco sentidos, é uma árvore;
* **Animal**: é vivo e tem os cinco sentidos:
  * Ser humano: tem cinco sentidos, pensa e fala, é bípede e vive em média 75 anos;
  * Gato: tem cinco sentidos, mia, é quadrúpede e vive em média 20 anos;
  * Cão: tem cinco sentidos, late, é quadrúpede e vive em média 20 anos.

Represente essas coisas do mundo real com classe, classe abstrata, herança e polimorfismo de orientação a objetos.

O resultado do print no terminal deverá se parecer com isto:

```dart
Girassol: é uma planta, não tem os cinco sentidos, é uma flor.
Laranjeira: é uma planta, não tem os cinco sentidos, é uma árvore.
Ser humano: tem cinco sentidos, pensa e fala, é bípede e vive em média 75 anos.
Gato: tem cinco sentidos, pensa e fala, é quadrúpede e vive em média 20 anos.
Cão: tem cinco sentidos, pensa e fala, é quadrúpede e vive em média 20 anos.
```

### 06. Resposta

```dart
abstract class SerVivo {
    
    String nome;
    String tipo;

    SerVivo(this.nome, this.tipo);

    void mostrarCaracteristicas();

}

class Planta extends SerVivo {

    Planta(String nome, String tipo) : super(nome, tipo);

    @override
    void mostrarCaracteristicas() {
        print('$nome: é uma planta, não tem os cinco sentidos, é uma $tipo');
    }

}

class Animal extends SerVivo {
    
    int tempoVida;

    Animal(String nome, String tipo, this.tempoVida) : super(nome, tipo);

    @override
    void mostrarCaracteristicas() {
        print('$nome: tem cinco sentidos, pensa e fala, é $tipo e vive em média $tempoVida anos');
    }

}

void main() {
    
    Planta girassol = Planta('Girassol', 'flor');
    girassol.mostrarCaracteristicas();
    Planta laranjeira = Planta('Laranjeira', 'árvore');
    laranjeira.mostrarCaracteristicas();

    Animal humano = Animal('Ser humano', 'bípede', 75);
    humano.mostrarCaracteristicas();
    Animal gato = Animal('Gato', 'quadrúpede', 20);
    gato.mostrarCaracteristicas();
    Animal cao = Animal('Cão', 'quadrúpede', 20);
    cao.mostrarCaracteristicas();

}
```


### 07. Definindo a interface para agendamento

Crie uma interface chamada `Agendamento` que inclua os métodos `calculaDuracaoConsulta()` e `verificaDisponibilidade()`. Esses métodos devem ser abstratos e servem como base para diferentes tipos de profissionais de saúde implementarem suas regras de agendamento.

Você não precisa exibir nada no terminal! Apenas crie o código com a estrutura da interface.

### 07. Resposta

```dart
abstract class Agendamento {
    
    void calculaDuracaoConsulta();
    void verificaDisponibilidade();

}
```

### 08. Implementando a interface em uma classe de médico

Implemente a interface `Agendamento` na classe `Medico`. A classe `Medico` deve fornecer uma implementação concreta dos métodos `calculaDuracaoConsulta()` e `verificaDisponibilidade()`. Considere que, para médicos, a duração padrão da consulta é de 30 minutos, e a disponibilidade é verificada com base em um calendário de agendamentos previamente existente.

### 08. Resposta

```dart
class Medico implements Agendamento {
    
    @override
    void calculaDuracaoConsulta() {
        // Implementação: duração padrão de 30 minutos
        print("duração de 30 minutos");
    }

    @override
    void verificaDisponibilidade() {
        // Implementação: verificar disponibilidade no calendário
        print("verificar disponibilidade no calendário");
    }

}
```
### 09. Implementando a interface em uma classe de dentista

Adicione um novo tipo de profissional ao sistema criando uma classe `Dentista` que também implementa a interface `Agendamento`. Defina a implementação do método `calculaDuracaoConsulta()` considerando que as consultas odontológicas duram 45 minutos. No método `verificaDisponibilidade()`, implemente a lógica para verificar a disponibilidade, considerando que os dentistas têm intervalos de 15 minutos entre consultas.

### 09. Resposta

```dart
class Dentista implements Agendamento {
    
    @override
    void calculaDuracaoConsulta() {
        // Implementação: duração de 45 minutos
        print("duração de 45 minutos");
    }

    @override
    void verificaDisponibilidade() {
        // Implementação: verificar disponibilidade considerando intervalos de 15 minutos
        print("verificar disponibilidade considerando intervalos de 15 minutos");
    }

}
```

### 10. Criando um gerenciador de agendamentos de consulta

Crie uma classe chamada `GerenciadorDeAgendamentos` que contenha uma lista de objetos que implementam a interface Agendamento. Adicione métodos para adicionar novos profissionais à lista e para calcular e exibir a duração das consultas e a disponibilidade de todos os profissionais cadastrados no sistema.

A ideia aqui não é exibir nada no terminal, apenas praticar a lógica do código. Portanto, não se preocupe em instanciar ou criar objetos. Foque apenas na lógica da classe `GerenciadorDeAgendamentos` e seus métodos.

### 10. Resposta

```dart
class GerenciadorDeAgendamentos {
    
    List<Agendamento> profissionais = [];

    void adicionarProfissional(Agendamento profissional) {
        profissionais.add(profissional);
    }

    void exibirDuracaoEDisponibilidade() {
        for (Agendamento profissional in profissionais) {
            profissional.calculaDuracaoConsulta();
            profissional.verificaDisponibilidade();
        }
    }

}
```

### 11. Testando o sistema de agendamento

Implemente um código de teste onde você cria instâncias das classes `Medico` e `Dentista`, adiciona essas instâncias ao `GerenciadorDeAgendamentos`, e chama os métodos para calcular e exibir a duração das consultas e verificar a disponibilidade para novos agendamentos. Verifique se o sistema está funcionando conforme o esperado.

### 11. Resposta

```dart
void main() {

    Medico medico = Medico();
    Dentista dentista = Dentista();

    GerenciadorDeAgendamentos gerenciador = GerenciadorDeAgendamentos();
    gerenciador.adicionarProfissional(medico);
    gerenciador.adicionarProfissional(dentista);

    gerenciador.exibirDuracaoEDisponibilidade();
    
}
```


# 05. Mixins

## Mexendo com mixins no Dart

**bin/anybank.dart**

```dart
import '../lib/conta.dart';

void main() {

    ContaCorrente contaChris = ContaCorrente("Chris", 4000);
    ContaPoupanca contaDenise = ContaPoupanca("Denise", 4000);
    ContaEmpresa contaMateus = ContaEmpresa("Mateus", 2000);
    ContaInvestimento contaMateus = ContaInvestimento("Roberta", 2000);

    contaChris.imprimirSaldo();
    contaChris.enviar(4300);
    
    contaDenise.imprimirSaldo();
    contaDenise.enviar(4300);
    contaDenise.calculaRendimento();
    contaDenise.imprimirSaldo();

    contaMateus.enviar(1000);
    contaRoberta.receber(1000);

}
```

**lib/conta.dart**

```dart
abstract class Conta {

    String titular;
    double _saldo;

    Conta(this.titular, this._saldo);

    void receber(double valor) {
        _saldo += valor;
        imprimeSaldo();
    }

    void enviar(double valor) {
        if (_saldo >= valor) {
            _saldo -= valor;
            imprimeSaldo();
        }
    }

    void imprimeSaldo() {
        print("O saldo atual de $titular, é R\$$_saldo");
    }

}

class ContaCorrente extends Conta {

    double empresimo = 300;

    ContaCorrente(super.titular, super._saldo);

    @override
    void enviar(double valor) {
        if (_saldo + emprestimo >= valor) {
            _saldo -= valor;
            imprimeSaldo();
        }
    }

}

class ContaPoupanca extends Conta {

    double rendimento = 0.05;

    ContaPoupanca(super.titular, super._saldo);

    void calculaRendimento() {
        _saldo += _saldo * rendimento;
    }

}

mixin Imposto {
    
    double taxa = 0.03;

    double valorTaxado(double valor) {
        return valor * taxa;
    }

}

class ContaEmpresa extends Conta with Imposto {
    
    ContaEmpresa(super.titular, super._saldo);

    @override
    void enviar(double valor) {
        if (_saldo >= valor + valorTaxado(valor)) {
            _saldo -= valor + valorTaxado(valor);
            imprimeSaldo();
        }
    }
    
    @override
    void receber(double valor) {
        _saldo += valor - valorTaxado(valor);
        imprimeSaldo();
    }

}

class ContaInvestimento extends Conta with Imposto {
    
    ContaInvestimento(super.titular, super._saldo);

    @override
    void enviar(double valor) {
        if (_saldo >= valor + valorTaxado(valor)) {
            _saldo -= valor + valorTaxado(valor);
            imprimeSaldo();
        }
    }

    @override
    void receber(double valor) {
        _saldo += valor - valorTaxado(valor);
        imprimeSaldo();
    }

}
```

Temos a tarefa de **criar 2 novas contas**:
* Conta **Investimento**.
* Conta **Empresa**.

Ambas terão uma funcionalidade de **cálculo de imposto**.

### Trabalhando com *Mixins* no Dart

A cada transação ou transferência que ocorrer em uma conta investimento ou em uma conta empresa, será aplicado um imposto. Por exemplo: se uma empresa transferir R$ 1.000,00, haverá um imposto de 3%. Assim, ao enviar R$ 1.000,00, será necessário pagar R$ 1.030,00, e ao receber, o valor será reduzido para R$ 970,00. Isso se aplica **tanto à conta investimento quanto à conta empresa**.

Um detalhe importante é que **ambas as contas terão a mesma funcionalidade**. Nesse caso, poderíamos pensar em usar herança, mas isso implicaria que todas as outras contas que herdam de Conta também precisariam ter esse cálculo de imposto.

Não é possível usar interface, pois isso demandaria uma implementação diferente para cada classe que a implementasse. Já no caso das contas investimento e empresa, **a implementação é a mesma**.

Além disso, foi especificado que **o cálculo de imposto pode ser aplicado em qualquer lugar no banco** onde seja necessário. Será um **valor fixo**, usado sempre que for necessário calcular o imposto sobre algum valor. Portanto, é uma funcionalidade consistente que **não pode ser herdada** por outros objetos, **nem ser criada como uma interface**.

A solução é utilizar uma funcionalidade do Dart chamada ***Mixins***.

### Utilizando a funcionalidade **`mixin`**

```dart
mixin Imposto {

    double taxa = 0.03;

    double valorTaxado(double valor) {
        return valor * taxa;
    }

}
```

* **Herança** utiliza a palavra reservada `extends`;
* **Interface** utiliza a palavra reservada `implements`.
* **Mixin** utiliza a palavra reservada `with`.

```dart
class ContaEmpresa extends Conta with Imposto {
    ...
}
```

### O que são *Mixins*

Mixins são conjuntos de **funcionalidades** que podem ser aplicadas a outras classes de **forma esporádica**. Pense no exemplo da capacidade de **voar**: ela pode ser aplicada tanto a aves quanto a aviões, embora não compartilhem uma classe comum, ressaltando a **flexibilidade** dos Mixins.

## Para saber mais: mais sobre mixins

### O que são mixins?

* **Mixins** são uma forma de **reutilizar código** em Dart **sem a necessidade de criar uma hierarquia** de herança complexa. 
* É como **adicionar uma característica sem precisar de uma implementação complicada** de superclasses. 
* Pense que você cria um **pequeno trecho de código** que pode ser reaproveitado para **executar alguma coisa** dentro do código.

### Por que usar mixins?

* Podemos compartilhar comportamentos entre classes sem criar uma hierarquia rígida.
* Mixins permitem combinar diferentes características em uma única classe.
* Funciona quase como **múltiplas heranças**.

```dart
mixin HabilidadeVoar {

    void voar() {
        print('Estou voando!');
    }

}

mixin HabilidadeNadar {

    void nadar() {
        print('Estou nadando!');
    }

}

class Pessoa {

    String nome;

    Pessoa(this.nome);

}

class SuperHeroi extends Pessoa with HabilidadeVoar, HabilidadeNadar {

    SuperHeroi(String nome) : super(nome);

}

void main() {

    SuperHeroi superHeroi = SuperHeroi('Super');
    superHeroi.voar();
    superHeroi.nadar();

}
```

* Nos **mixins `HabilidadeVoar` e `HabilidadeNadar`**, definimos as habilidades de voar e nadar (que são métodos);
* A **classe `Pessoa`** representa uma pessoa comum;
* A **classe `SuperHeroi`** herda de `Pessoa` e utiliza os mixins `HabilidadeVoar` e `HabilidadeNadar`. Ou seja, temos um super-herói que é uma pessoa que pode voar e nadar;
* Usamos a palavra-chave `with` para "misturar" ou "adicionar" os mixins à classe.

**Mixins**:  
* Pequenos trechos de códigos que **adicionam funcionalidades a uma classe**.
* Reutilizamos os mixins para adicionar métodos em uma classe. Porém o modo como um mixin faz isso é mais flexível e aberto se compararmos com herança de uma classe comum.
* Os mixins **complementam a herança tradicional**, permitindo que você crie classes mais completas sem lidar com heranças complexas.
* Mixins **não podem ter construtores**.
* A ordem dos mixins importa, pois pode haver conflitos de nomes.

## Princípios de POO

Primeiramente, recebemos tarefas com **problemas práticos** que precisavam ser resolvidos. A partir desses problemas, analisamos, **buscamos soluções** e as implementamos.

Com a prática você percebe que:
* **Problemas se repetem**.
* Pessoas encontram soluções.
* Essas soluções viram guias e padrões (POO).
* **Separar responsabilidades**.
* **Refletir sobre repetição de código**.
* POO tem mais a oferecer.

    Copiar e colar soluções não é uma boa forma de resolver problemas.

## Lista de exercícios

### 01. Criando um mixin para cálculo de taxa de bagagem

Crie um mixin chamado `TaxaBagagem` que tenha uma variável `taxa` com o valor de 10% e um método `calcularTaxa(double valor)` que retorne o valor da taxa sobre o total da passagem. Este mixin será utilizado para calcular a taxa adicional nas passagens que incluem bagagem.

### 01. Resposta
```dart
mixin TaxaBagagem {

    double taxa = 0.10;

    double calcularTaxa(double valor) {
        return valor * taxa;
    }

}
```

### 02. Criando uma passagem

Considere o seguinte código da classe abstrata `Passagem`:

```dart
abstract class Passagem {

    String cliente;
    double valorBase;

    Passagem(this.cliente, this.valorBase);

    double calcularPrecoFinal() {
        return valorBase;
    }

}
```

Implemente a classe `PassagemComBagagem` que herda de `Passagem` e utiliza o mixin `TaxaBagagem`. Sobrescreva a função de `calcularPrecoFinal`, de modo que o cálculo do preço final da passagem inclua a taxa de bagagem utilizando a função `calcularTaxa` do mixin.

### 02. Resposta
```dart
class PassagemComBagagem extends Passagem with TaxaBagagem {

    PassagemComBagagem(super.cliente, super.valorBase);

    @override
    double calcularPrecoFinal() {
        return valorBase + calcularTaxa(valorBase);
    }

}
```

### 03. Criando um mixin para cálculo de taxa de bagagem

Implemente a classe `PassagemSemBagagem` que herda de `Passagem`, mas não utiliza o mixin `TaxaBagagem`. A função `calcularPrecoFinal` para esta classe deve retornar apenas o valor da passagem sem qualquer taxa adicional.

### 03. Resposta
```dart
class PassagemSemBagagem extends Passagem {

    PassagemSemBagagem(super.cliente, super.valorBase);

}
```

### 04. Implementando controle de acesso com mixins

Você está desenvolvendo um sistema básico de gerenciamento para uma loja online. O sistema precisa gerenciar diferentes operações, como deletar usuários e adicionar produtos, mas somente administradores têm permissão para realizar essas operações críticas. Afinal, imagine se um usuário comum pudesse deletar e adicionar produtos em um site? Seria, sem dúvida, um caos. O usuário comum pode apenas comprar produtos, mas não modificá-los.

Para evitar a repetição de código ao verificar as permissões, você deve utilizar mixins no Dart para compartilhar essa funcionalidade de controle de acesso entre diferentes partes do sistema.

Comece assim: crie um mixin chamado `ControleAcesso` que tenha uma função `verificarPermissaoAdmin(String papel)` que retorne `true` se o papel for igual a `'admin'` e `false` caso contrário. Este mixin será utilizado para verificar se um usuário tem permissão para realizar operações críticas no sistema.

### 04. Resposta
```dart
mixin ControleAcesso {

    bool verificarPermissaoAdmin(String papel) {
        return papel == 'admin';
    }

}
```

### 05. Implementando controle de acesso com mixins

Implemente a classe `ServicoUsuario` que utilize o mixin `ControleAcesso`. Adicione um método `deletarUsuario` que somente permitirá a operação se o usuário tiver a permissão de administrador. Caso contrário, exiba a mensagem "Acesso negado". Escreva a classe no mesmo arquivo Dart em que você fez o mixin `ControleAcesso`.

### 05. Resposta
```dart
class ServicoUsuario with ControleAcesso {

    void deletarUsuario() {
        if (verificarPermissaoAdmin('admin')) {
            print('Usuário deletado');
        } else {
            print('Acesso negado');
        }
    }

}
```

### 06. Produzindo uma classe de adição de produtos

Escreva o código de uma classe chamada ServicoProduto, que utilize o mixin ControleAcesso. Adicione um método adicionarProduto, que somente permitirá a operação se o usuário tiver a permissão de administrador. Caso contrário, exiba a mensagem "Acesso negado". Implemente esta nova classe no mesmo arquivo que a classe `ServicoUsuario` e o mixin `ControleAcesso`.

### 06. Resposta
```dart
class ServicoProduto with ControleAcesso {

    void adicionarProduto() {
        if (verificarPermissaoAdmin('admin')) {
            print('Produto adicionado');
        } else {
            print('Acesso negado');
        }
    }

}
```

### 07. Melhorando a qualidade do código

Analise o código das classes `Serviço Usuário` e `ServicoProduto`. Identifique qualquer código repetitivo nas funções que verificam a permissão e refatore esse código, utilizando métodos auxiliares ou ajustando a lógica para evitar duplicação, garantindo que ambas as classes mantenham a funcionalidade adequada.

### 07. Resposta
```dart
mixin ControleAcesso {

    bool verificarPermissaoAdmin(String papel) {
        return papel == 'admin';
    }

    void executarOperacao(String papel, Function operacao) {
        if (verificarPermissaoAdmin(papel)) {
            operacao();
        } else {
            print('Acesso negado');
        }
    }

}

class ServicoUsuario with ControleAcesso {

    void deletarUsuario() {
        executarOperacao('admin', () => print('Usuário deletado'));
    }

}

class ServicoProduto with ControleAcesso {

    void adicionarProduto() {
        executarOperacao('admin', () => print('Produto adicionado'));
    }
    
}
```